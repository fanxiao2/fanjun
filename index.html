<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.1.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.1.1" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="二哥笔记">
<meta property="og:url" content="https://pmku.com/index.html">
<meta property="og:site_name" content="二哥笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="FanJun">
<meta name="twitter:card" content="summary"><title>二哥笔记</title><link ref="canonical" href="https://pmku.com/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.1.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.1.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">二哥笔记</div><div class="header-banner-info__subtitle">思维、技术、科技、财富</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/09/02/01%20_%20%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%98%E7%A7%80%E7%9A%84%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%EF%BC%9F/">什么是优秀的产品经理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-09-02</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-09-03</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="引言"   >
          <a href="#引言" class="heading-link"><i class="fas fa-link"></i></a>引言</h3>
      <p>做了产品经理这么多年，最难的事情是和长辈、朋友们解释我是做什么的。常见的对话通常是这样的：</p>
<blockquote>
<p>“你是做什么的？”<br>“我是产品经理。”<br>“所以你写代码吗？”<br>“我不写。我主要是负责决定产品的体验和功能。”<br>“哦，所以你是做设计的？”<br>“其实也不是。我更多的是组织产品团队，决定应该推出什么样的产品，拥有什么样的功能。”<br>“就是说，你实际上啥也不做， 就动动嘴？”<br>“。。。”</p>
</blockquote>

        <h2 id="产品经理的定义"   >
          <a href="#产品经理的定义" class="heading-link"><i class="fas fa-link"></i></a>产品经理的定义</h2>
      <p>这几年，产品经理这个职业越来越热门，无数的朋友同学来问我怎么转行做产品经理，但是每次我详细问他们是怎么理解产品经理这个职业的，却发现大家说什么的都有。</p>
<ul>
<li>有的说是做科技的还不用写代码，感觉终于有自己可以做的科技岗位了；</li>
<li>有的说经理嘛，听上去就是权利挺大的，一毕业如果去做这个倍儿有面子；</li>
<li>还有的说，将来想自己创业做老板，产品经理是最合适的敲门砖。</li>
</ul>
<p>实际上，我对产品经理的理解是，带领产品团队，在高效的时间内推出满足用户需求的产品。这里面包含四点。</p>
<ul>
<li>第一是，“经理”的意思，更多是说产品经理要能够带领和鼓舞一个产品团队，这里面有工程师、设计师、律师、营销经理、数据科学家等等不同职位的人。这就要求产品经理具备管理能力、处理团队人际关系的能力、统筹大家工作的能力、制定高效工作流程的能力等。</li>
<li>第二是，能够理解用户需求。通过市场调查、用户调研等等，从用户不经意的小抱怨中找到巨大的机会，把这些用户需求转化成切实可行的产品功能，让用户的体验更加通畅。</li>
<li>第三是，能够高效执行。产品开发的过程从来都是紧赶慢赶，有 deadline 要赶，或者要在竞争对手推出新品的时候，快速行动推出自己的新品抢占市场份额。这就需要产品经理能够做好项目管理，提前计划，在团队成员被一些外部因素阻碍进程的情况下，快速有效地帮助他们解决这些问题（也叫作 blocker）。在科技行业，常说的一句话就是要 move fast，快速行动，高效执行。</li>
<li>第四是，要有长远的眼光，能够策略性地制定产品的下一步规划，让这个产品能够一步步走向成功。而不能仅仅停留在这一版产品，或者现在正开发的这个功能，而是有长远的眼光。这也是非常重要的一点。
        <h2 id="对产品经理的几个误解"   >
          <a href="#对产品经理的几个误解" class="heading-link"><i class="fas fa-link"></i></a>对产品经理的几个误解</h2>
      </li>
</ul>

        <h3 id="1-产品经理是老板，工程师、设计师等都得听我的。"   >
          <a href="#1-产品经理是老板，工程师、设计师等都得听我的。" class="heading-link"><i class="fas fa-link"></i></a>1. 产品经理是老板，工程师、设计师等都得听我的。</h3>
      <p>我在 Facebook 做产品经理的第一个月，就犯了一个错误。我和一位工程师说：“我和你老板说了，安排你来做这个项目。”</p>
<p>没想到这位工程师马上就火了，他说“什么叫安排我来做这个项目，从来都是我自己决定做什么项目”。原来，在 Facebook，工程师最终可以决定自己想做什么项目，就算是公司老板都不能安排他做自己不喜欢的项目，就更别说产品经理了。</p>
<p>我刚刚开始工作的时候，觉得既然我是经理，大家就应该听我的指挥，结果一来就碰了壁。其实，正确的做法是和工程师商量，跟他讲清这个项目为什么很重要， 能解决什么问题，然后说服他来做这个项目，而不是指望他被动地接受安排。</p>
<p>在很多公司，产品经理虽然管理一个产品团队， 但并不是团队工程师或者设计师的老板，没有直接的生杀大权，当然团队的工程师或者设计师就不会完全听从你的“指挥”，而是需要你来说服他们，激励他们，让他们发挥能动性自己主动做事情。在遇到分歧的时候，也要尊重他们的想法，慢慢商量，而不是跋扈专横地直接做决定。</p>

        <h3 id="2-产品经理的工作就是画画-UI-图。"   >
          <a href="#2-产品经理的工作就是画画-UI-图。" class="heading-link"><i class="fas fa-link"></i></a>2. 产品经理的工作就是画画 UI 图。</h3>
      <p>前一段时间，一些想转行做产品经理的朋友邀请我去回答问题。让我意外的是，一堆正在准备产品经理面试的人，问我最多的却是：“产品经理平时都用什么软件画图？我怎么样才能快速提升作图技能？” 在他们看来，要是能灵活掌握画图软件，拿到产品经理工作的几率就会增大很多。然而在我看来，面试的时候，公司指望通过画图技能决定招谁，这是一个非常大的误区。</p>
<p>很多初级的产品经理花大量时间写产品需求文档，看看其他产品怎么做的，东抄抄西凑凑，再用 wireframe 软件画个按钮，加个对话框，加班加点，追求完美，是要方按钮还是圆按钮，要精益求精，然后把图纸给设计师精修一下，最后抛给工程师，让他们照着图纸原封不动地开发出来。其实，这只是产品经理工作的一个非常小的部分，画草图的目的也不是为了让工程师原封不动照做， 而更多地是清晰沟通产品的想法。</p>
<p>对于产品经理来说，最重要的工作是决定该做什么。这包含：</p>
<ul>
<li>第一，对市场以及用户需求的深入了解；</li>
<li>第二，能够制定出合理有效的成功指标，然后用成功指标推动产品功能的发展；</li>
<li>第三，思考帮助用户解决这个问题应该有什么样的用户体验， 在现有产品不受欢迎的情况下， 快速找到问题所在，并制定计划进行改进。</li>
</ul>
<p>准确地说，区分一个优秀的产品领袖和普通的产品经理，更多的是看他们思考的部分。说白了，画图的工作你做得再好， 也不会比设计师做得好，如果你花时间的地方，团队其他人比你做得更好，那你就浪费了团队的时间，也没有发挥出自己的优势。</p>

        <h3 id="3-产品经理就是催工程师干活的。"   >
          <a href="#3-产品经理就是催工程师干活的。" class="heading-link"><i class="fas fa-link"></i></a>3. 产品经理就是催工程师干活的。</h3>
      <p>之前有个笑话说，产品经理就是“程序员鼓励师”，就连我自己刚入行的时候，也觉得我的工作就是要催工程师快狠准，多干活，像监工一样，生怕他们偷懒耍滑。后来，做得久了，仔细观察过工程师的工作，发现偷懒耍滑的其实占少数，大部分工程师是很拼命的，也很认真，工作态度还是非常积极的。</p>
<p>产品之所以拖延，其实更有可能是以下的原因：</p>
<ul>
<li>第一，产品的需求或者由于前期准备不充足或新的用户反馈需要修改，从而增加了开发时间。</li>
<li>第二，开发时间的前期预估不准确。本来需要几个星期才可以完成的事情，之前过于乐观地估计了更短的时间。</li>
<li>第三，沟通遇到了问题，当工程师发现某个功能其实难度非常高， 执行压力大的时候，没有尽早沟通，deadline 快到了才说，耽误了工期。</li>
<li>第四，产品功能的设计过于烦琐，本来可以简化的功能，却花费了大量的时间，其实这个功能根本不需要浪费这么长的时间。</li>
</ul>
<p>尽管产品经理有责任保证产品按期交付，但你看，真正能够解决高效开发的方式，并不是狠催工程师、每天夺命 call 这么简单直接， 这就需要产品经理能够发现上述问题，及时解决，从而才能高效执行。</p>

        <h2 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>
      <p>欢迎你和我一起开启产品经理的旅程，第一篇文章我讲解了产品经理的工作性质以及工作内容：产品经理能够带领产品团队，在高效的时间内推出用户满意的产品；产品经理决定什么时候该推出什么样的产品，应该具备什么功能，并且能够用策略性的眼光指引整个产品长期发展的方向。</p>
<p>我还讲了产品经理常见的几个误区。</p>
<ul>
<li>第一，产品经理并不是管人的老板，并不能决定人事调度，更多的时候需要通过影响来说服团队成员， 这其中包括非常多不同职能的同事，比如工程师、设计师、数据科学家等等。</li>
<li>第二，产品经理的工作并不只是画画草图、画画流程图。真正好的产品经理，能够对产品的功能满足什么样的用户、什么样的需求了如指掌，能够高效地沟通。</li>
<li>第三，产品经理的工作并不是催工程师干活。虽然对于产品经理来说， 项目管理是一个必不可少的技能，保证产品按时交付是产品经理的责任，但是在实际操作中，导致产品不能按期交付的原因很多时候并不是工程师偷懒耍滑，而是前期准备、时间估计、面对变化缺乏快速解决方案等导致的。
        <h2 id="思考题"   >
          <a href="#思考题" class="heading-link"><i class="fas fa-link"></i></a>思考题</h2>
      </li>
</ul>
<p>最后留一个思考题，想一想，如果你要为一家创业公司招聘一个产品经理，你会如何制定评判标准呢？</p>

        <h2 id="精选留言"   >
          <a href="#精选留言" class="heading-link"><i class="fas fa-link"></i></a>精选留言</h2>
      <p>总结的很不错， 还有一点可以特别说明下。 “经理”是指经人理事，并非指职位。产品经理的工作边界不清晰，一切和产品相关的工作都要涉及，这样才能足够的了解用户和需求，更能了解研发、测试、推广、使用中存在的问题。</p>
<p>原型和需求说明文档，只是便于沟通的过程资产，有很多产品经理是不用画原型的。</p>
<p>如果我要为一家创业公司招聘一个产品经理，我会围绕以下几点制定评判标准</p>
<ol>
<li><p>产品经理具备管理能力</p>
</li>
<li><p>处理团队人际关系的能力</p>
</li>
<li><p>统筹大家工作的能力</p>
</li>
<li><p>制定高效工作流程的能力</p>
</li>
<li><p>理解用户需求能力</p>
</li>
<li><p>高效执行能力</p>
</li>
<li><p>产品规划能力</p>
</li>
</ol>
<p>1 战略 产品经理首要任务是战略；理解产品需求，明白产品方向 制定产品规划…</p>
<p>2 战术 在战略的指导下能够将方向细化可落地，有深挖产品需求的能力</p>
<p>当然沟通呀，协调呀是所有有应该具备的能力.</p>
<p>虽然朗读人读的不错，但是更希望作者本人可以发声😁</p>
<p>哈哈 下次让他们帮我组织个和大家互动的机会</p>
<p>产品经理招聘的一点心得 抛砖引玉</p>
<p>第一，你对于用户理解，实践的实例</p>
<p>第二，你对于用户场景能力的把控</p>
<p>第三，对自己做过产品的场景还原 有什么新的问题</p>
<p>第四，对于用户的目标实现方式如何解决，抽离出80％的用户需求 用户价值的提取</p>
<p>第五，你对于目前公司的产品解决用户什么问题如何看</p>
<p>第六，说你最成功 最囧的产品经历 获得什么收获</p>
<p>说得非常好。第六个问题我经常问</p>
<p>我把身边目前能够接触到的环节，大部分把产品经理定义为：业务需求的收集者、原型和文档的撰写者、工作汇报的发言者、项目的问题跟进者、和进度跟踪者。</p>
<p>但我认为产品经理应该是</p>
<p>1、问题的定义者</p>
<p>2、收益的评估者</p>
<p>3、方案的整合者</p>
<p>学习了。工作中 的确看到很多人都对产品经理有一些误区 甚至部分产品经理 对自己的职业定位 规划 都极度不清晰。虽然是一名技术工程师，但最近一直在关注产品专栏，懂产品 懂技术 懂用户心理 懂工程师心理 协助起来 各team之间也许会更加顺畅。</p>
<p>本人是一个工程师，大家都应该有类似的经历，就是产品在需求评审过后经常变更需求，改动有大有小，改动的点都有他们的理由，有一个问题是如果需求经常改动是跟产品经理能力有关系吗？是不是前期的工作没做好导致？一个优秀的产品会让这种问题成为常态吗</p>
<p>有个疑问，文中提到硅谷的产品经理不能直接安排工程师工作，请问产品经理有考核工程师绩效的权力吗？如果产品经理没有考核权力，感觉领导力，执行力就很难做到。如果产品经理有考核权力，那理论上你安排工程师工作，工程师不敢拒绝的。至少国内的文化是这样，一般没人敢拒绝考核自己的领导。</p>
<p>老师您好，</p>
<p>关于您提到的产品新人的一些误区中，产品新人最关注的是原型设计软件，及如何快速学习文档撰写的方法，究其原因是新人在刚刚入行，且没有系统的学习研究的前提下，这种可量化的能力点是最好上手和执行的。不排除新人对产品经理岗位理解的深度不够的原因。</p>
<p>所以我想请教老师的是，对于产品新人，想到深入分析市场和用户需求，从需求落实到功能，从而优化用户体验，往往找不到切入点，不知道从哪里开始入手。</p>
<p>这方面希望有机会能得到老师的解答，谢谢😜～</p>
<p>我觉得一是多跟用户沟通。当你和用户沟通的时间最长沟通的次数最多的时候，你就自然而然成了用户的专家可以帮你找到切入点。第二我觉得是多了解其他的产品。比如说你的竞争对手的产品他们是如何解决你现在正解决的问题的</p>
<p>产品经理的核心我认为是理解用户，理解公司，理解团队，理解自己</p>
<p>其实老板就是产品经理，慢慢老板退出市场后，我们就成为产品经理，因为我们要为公司创造价值</p>
<p>如果是创业公司，可能会比较注重竞品分析，产品战略，产品迭代这些统筹全局的技能吧，当然基本功也是有一定的要求的。</p>
<p>产品是特定场景下的解决方案，那么产品经理是不是提供并落实这个解决方案的岗位？</p>
<p>嗯 这个描述比较到位 产品经理的最终结果是高效执行</p>
<p>看下来像是我们公司项目经理+产品经理的合体</p>
<p>快速交付有价值的产品~</p>
<p>1.最重要的是同理心，理解用户。</p>
<p>2.其次是掌握产品的相关技能。</p>
<p>3.了解市场，做好产品规划。</p>
<p>4.保证产品快速交付落地。</p>
<p>总结的很好！</p>
<p>很多其他工作干不了就只能干产品经理。产品经理和架构师都是非常重要的职位，只不过混迹在这两个圈里的人实在是投机份子太多。我在想就这两个职位而言应该公司花点精力定向培养靠谱的工程师或者相关人员应该产出比市场上乱寻强的多</p>
<p>创业公司招产品经理的话需要考虑到公司的整体环境以及对产品经理这个角色的需求，个人觉得主要有以下三点吧。</p>
<ol>
<li><p>要有一个宏观的视角，要结合公司的战略去确定正确产品方向，制定合理的产品计划。</p>
</li>
<li><p>需要比较全面的技能，在创业公司通常都是一个人当多个人来用，比如说从产品方向的制定，前期的市场调研，产品框架的搭建，产品功能的设计到产品上线后的运营和营销，都需要产品经理来参与。</p>
</li>
<li><p>有比较强的影响力和推动力。能够把团队团结起来，能够激励大家一起更好的完成相关的工作。</p>
</li>
</ol>
<p>产品经理跟传统软件里的项目经理有什么区别，要会软件工程的知识吗？</p>
<p>总结的太好了❤️</p>
<p>1.能够找到正确的问题；</p>
<p>2.能够协调资源高效、正确地解决问题；</p>
<p>3.能够带领团队一起成长。</p>
<p>1，沟通和表达能力–交流过程中不仅能反应一个人的逻辑思维，还能看出一个人的做事风格，讲话有条理不废话可以从侧面反应出逻辑思维能力较强做事干净利落</p>
<p>2，对自己的职业生涯是否有清晰的规划–如果连自己的事业都经理不好或者漫无目标，那么怎么会有激情和能力去产出一个优秀的产品？律人先律己</p>
<p>3，其他的专业技能我就不再赘述</p>
<p>作为一个刚好想要转行做产品的初级外行人，我的理解可能比较弱了，但还是要交上自己的作业:</p>
<p>如果我的创业公司要招聘一位产品经理，我首先会从以下几个角度去判定:</p>
<p>1.应聘者的段位，经验，（高级产品经理or初级产品or转行产品等等），成果。这将决定我接下来的问题走向。</p>
<p>2.有无相关行业的从业经验。考虑对我的创业公司行业了解度，能否帮助我更好的进入这个行业。</p>
<p>3.无经验的产品应聘者对职位、行业的理解，为转行做过怎样的努力，有怎样的成果。</p>
<p>4.对我公司的了解程度，想法，对产品研发的个人见解或建议。</p>
<p>5.能为公司做什么，想要做什么。</p>
<p>1.应该讲讲如何从别的专业转到产品经理</p>
<p>2.重点讲初级产品怎么进阶</p>
<p>3.中级产品怎么进阶</p>
<p>4.高级的是什么境界</p>
<p>如果我为一家创业公司招聘产品经理，我制定的评判标准如下：</p>
<p>1、对市场以及用户需求的了解程度；</p>
<p>2、高效的执行能力；</p>
<p>3、产品规划能力；</p>
<p>4、管理能力；</p>
<p>5、处理人际关系的能力；</p>
<p>6、制定高效工作流程的能力；</p>
<p>7、统筹大家工作的能力；</p>
<p>初级产品经理从画图，写需求文档开始，我们这种30多岁的产品经理，要做深入市场调研，深入理解用户真实痛点，解决客户问题才是我们的目标</p>
<p>如果我是爱创业公司老板，评估产品经理的标准：</p>
<p>1.团队管理能力</p>
<p>2.产品管理能力</p>
<p>3.有效沟通能力</p>
<p>4.学习能力</p>
<p>01节的课后练习的回答：</p>
<p>第一步：分析当前创业环境，您自己创业还是合伙创业，还是打工创业？您在创业公司的职责，管技术管产品管项目？不同的条件影响到找来的产品经理的职责。简单的说，明确自己的用人需求。</p>
<p>假设，我是老板，来自传统行业，对产品已有初步想法，但正在组建团队，需要产品名额1人，做产品该做得全部事。</p>
<p>第二步：分析产品的需求。做的项目属于什么分类，有类似产品吗？有什么资源，有多少钱可烧，要什么时候上线运营？简单的说，明确产品工作的范围与强度</p>
<p>假设，我有钱，很多钱，要做另一个微信，把微信干死的产品。</p>
<p>第三步：制定评价规则与优先级。按前2步的场景，招靠谱的比招牛的好，创业嘛高风险行业。</p>
<p>标准A：能沟通，理解我也理解行业，说的话我听的懂，而且我能hold得住。</p>
<p>标准B：要全能，技术要懂，画图要懂，交互要懂，测试要懂，管理要懂。我要通过他来招其他岗位，作为我管理的工具。</p>
<p>标准C：有责任心，有实战经验，不要太年轻，有点经验，有点生活压力（有孩子有房贷等等）</p>
<p>第四步：现场考考他的产品能力。具体要产品的实操能力，什么工具的使用技巧等，不是最要紧的。</p>
<p>第一关：需求分析能力，看他的成色达到哪个阶段，能看的多远</p>
<p>第二关：抗压能力，看他面对压力的表现，如何处理不同意见和恶意评论</p>
<p>第三关：执行能力，看他如何制定计划与落实细节，细到哪个级别</p>
<p>产品经理最主要的能力如下</p>
<p>1.需求分析的能力～如何把需求变成可执行的产品功能</p>
<p>2.产品规划的能力</p>
<p>如何根据产品周期，实施调整产品功能</p>
<p>3.沟通协调的能力</p>
<p>如何调动各角色人保质保量把这件事情干好，按时交付</p>
<p>4.回归的能力</p>
<p>项目的过程中要不断回归，出现的问题及时纠正</p>
<p>大道至简，如今很火的产品几乎都是遵循这个规则。简单，方便，好用。</p>
<p>作为一个QA同样有一个产品梦，也希望有一天可以打造一款产品。</p>
<p>很开心看到很多工程师朋友也在听产品课程，互通协作是我一直在团队内部提倡的工作经验，高效的产出离不开每个对各个职能的理解和配合默契</p>
<p>曲老师您好，我认为作为一名产品经理应该具备以下几项能力：</p>
<p>1.能够制定产品的建设目标和各个关键节点</p>
<p>2.具有熟练的产品设计的技能</p>
<p>3.具有市场和竞品分析能力</p>
<p>4.能够通过各种方法挖掘用户的真实需求</p>
<p>5.良好的沟通能力和团队协作能力</p>
<p>6.熟悉所处行业的业务流程和相关标准</p>
<p>第一，对市场以及用户需求的深入了解；</p>
<p>第二，能够制定出合理有效的成功指标，然后用成功指标推动产品功能的发展；</p>
<p>第三，思考帮助用户解决这个问题应该有什么样的用户体验， 在现有产品不受欢迎的情况下， 快速找到问题所在，并制定计划进行改进。</p>
<p>在高效时间内，推出满足不同受众的需求的产品，（产品经理不能只考虑用户，比如供应链上下游，投资方）</p>
<p>好的产品经理一定是相处起来大家都觉得舒服的，有着极大的个人魅力和优秀小习惯。</p>
<p>就个人而言，我觉得要学着能看到不同人身上的优点，也要能听不同人的声音。要学着不吝啬完美，也要能乐于接受批评。</p>
<p>我对产品经理的理解是，产品经理的核心工作是为产品负责，管的是产品，而非团队，与团队其他角色的成员是协作关系。通常，在有产品经理的团队中，产品经理可以结合自己的工作之便，承担基本的团队或项目管理工作，但这些不是产品经理的主要工作，我觉得可以把它视为帮这样负责人打下手</p>
<p>如果是创业公司的产品经理，我的评判标准是：</p>
<p>1，产品规划和设计能力。主要目的是发现用户需求，设计有价值的产品来解决用户问题</p>
<p>2，协同团队，高效执行，正确地交付产品</p>
<p>希望能对不同阶段的产品经理应该如何更快速进阶给些建议或意见，多谢</p>
<p>战略眼光，战术制定，资源调配，战术执行</p>
<p>1:需要有管理能力，工作流程，工作效率，产品周期等的管理。</p>
<p>2:沟通能力，能够很好的处理团队的人际关系。</p>
<p>3:需求分析能力。</p>
<p>4:产品规划能力。</p>
<p>Les is more，好多成功产品都是很简单的功能，是巧合还是有什么玄机呢？</p>
<p>面试者解决问题的思考方式，对市场和用户需求是否具有敏锐的观察力，产品工作中是否有自己的方法论，</p>
<p>晓音老师，我想请问下，如何提升产品思考的深度和广度</p>
<p>一个是看看你老板都在想什么。这样可以提高你思考的广度，还有就是多研究研究，其他产品都在干什么。思考一下，如果你是产品经理会怎么做？</p>
<p>小f</p>
<p></p>
<p>0</p>
<p>产品经理 我的理解是 产品的经营管理，对产品要负责。</p>
<p>产品是解决用户问题而存在，如何协调内部资源高效快速发布超出用户预期的产品，是产品经理不断追求的目标。</p>
<p>那按照这样的说法，产品经理与项目经理的区别是什么？</p>
<p>我认为选择什么样的产品经理跟公司的目标有关！</p>
<p>真正能够开疆扩土的产品需要具备以下素质</p>
<p>(1)洞察用户与需求的能力：很多创业公司老板会给一个大方向，但是真正能够洞察用户，找准切入点，很关键！能帮助创业公司节省大量的试错成本</p>
<p>(2)沟通协调的能力:创业公司管理流程一般不完善，人员不统一，如何能够把大家凝成一股绳，为共同的目标努力，保质保量很重要！作者文中介绍的方法很好:讲述项目目标及项目重要性！</p>
<p>我认为自己或者国内很多产品最欠缺的是洞察用户洞察需求的能力，希望能得到作者的更多智慧～谢谢</p>
<p>沟通，协调，思考</p>
<p>是我对这个职位感兴趣呢，还是你讲的比较好，反正很感兴趣，这样的价格买这个课，真心良心价</p>
<p>老师您好，有两个问题想请教一下的，</p>
<p>第一个问题是就是在产品的MVP阶段当中，以及到产品上线运营之后，应该怎么让自己和团队能够时刻保证与自己的用户接触呢？PM本身或者是团队分工需要调整么(例如专门成立一个用研部门或者人员？)？有什么方法？</p>
<p>第二个问题是以下我在MVP阶段了解目标人群需求的思路和执行逻辑，但我不知道这样是否已经是算是“充分了解”呢？成熟的用户调研思路和流程又应该是怎样的呢？</p>
<p>1.       与“疑似”目标用户进行面对面交流，或者通过观察相似或相关产品现有的用户反馈，对于中间提到的需求点进行整理</p>
<p>产出物：用户的需求点总结。</p>
<p>2.       通过观察像搜索指数（例如百度指数）或其他渠道的数据收集，总结哪些需求点是核心并且进行聚类，目标人群有哪些共同特征。</p>
<p>产出物：需求点的聚类分析，前期版本的需求池以及优先度，目标人群的用户图谱</p>
<p>3.       形成产品MVP版本，请目标人群进行使用，观察用户使用产品时的操作和使用状态（包括什么时候使用，什么场地使用等等）</p>
<p>产出物：产品使用场景描述，产品操作流程逻辑描述</p>
<p>渴望能收到您的回复</p>
<p>我在第二章的最小化可行产品会讲。刚写完哈哈</p>
<p>1，逻辑思维。要求讲产品案例。</p>
<p>2，如何处理和工程师的关系。会问到尖锐的和工程师的矛盾，看并且如何处理这种矛盾。</p>
<p>3，是否愿意做项目经理的工作。这跟公司岗位定位有关系，也能知道其在产品中的工作内容。</p>
<p>无论是面产品还是面UI，都是创作型工种，会问手机里有哪些自己觉得不错的APP，为啥喜欢。</p>
<p>作为一个PM 确实有以后创业的打算，也觉得现在的工作可以作为未来创业时的预演。如果是创业公司的产品，可能会更看重如何做好mvp然后快速推广，立足一个细分需求后拓展产品的边界。再就是要有商业敏感性，毕竟创业公司第一要义是活下去～</p>
<p>第一次学习，支持下，会一直用心看下去的。</p>
<p>1、一定的管理能力，沟通良好</p>
<p>2、责任心，对自己负责的事情有比较高的验收标准</p>
<p>3、逻辑思考能力</p>
<p>4、主动思考的能力，思考产品长期发展的方向</p>
<p>5、执行力强</p>
<p>1、一定的管理能力，沟通良好</p>
<p>2、责任心，对自己负责的事情有比较高的验收标准</p>
<p>3、逻辑思考能力</p>
<p>4、主动思考的能力，思考产品长期发展的方向</p>
<p>5、执行力强</p>
<p>“处理团队人际关系的能力、统筹大家工作的能力”这个应该是属于项目经理要侧重的能力吧</p>
<p>沟通能力，整合资源的能力，对产品的理解能力。</p>
<p>产品拖延有可能是对开发工期判断不准，那应该如何更准确地预估周期呢？</p>
<p>一年的产品工作经验，现在找产品助理岗位，但是都没有找到，都想放弃了，我改怎么办呀，毕业一年真的好迷茫！</p>
<p>创业公司产品经理可能更注重能力的全面，因为创业公司多数情况下，一个人会担任多个人的职位，所以可能的要求：</p>
<p>1.产品经理的基本功：需求分析，原型设计，文档撰写</p>
<p>2.产品的领导力：产品经理的个人魅力和团队领导能力</p>
<p>3.产品的大局观：同时可能执行项目管理的职责，需要产品经理抽离出产品设计的微观层面，看产品和团队的格局。</p>
<p>1.产品经理硬实力，比如基础的工具使用、技术理解、交互设计能力等，因为创业公司进来要能立马干活儿，不可能招什么都不懂还要教的</p>
<p>2.行业经验和产品软实力，同上，进来要能立马干活，要看是否有相应行业的产品方法论</p>
<p>3.态度和韧性，创业公司需要的产品经理一定要非常喜欢自己做的事，因为在创业公司工作付出和收获一般是不成正比的，需要有其他的东西来支持</p>
<p>我觉得成熟的产品经理至少要有能力快速分解任务，管理需求的能力，如果这些都没有，很难想象可以推动项目进程。</p>
<p>如果让我找产品经理:我会从下面几个方面，制定标准</p>
<p>1、要能理解用户需求，以及需求分析与整合能力</p>
<p>2、人际关系与沟通能力</p>
<p>3、对战略的洞察力</p>
<p>4、对产品生命周期中的快速反应能力</p>
<p>我之前面试过一个很棒的姑娘，她之前在一家创业公司做产品。创业失败了，然后出来找工作。 总结来讲她的特点是1.能准确地理解问题，能体察出我的意图，然后针对性地回答。 2.表达思路清晰，从小到策略到公司所处大环境都能简洁明了地说清楚。3.不畏惧失败，她还帮创始人一起处理了公司资产变卖等等收尾工作。</p>
<p>『让正确的事相继发生』–邱岳</p>
<p>1，产品观</p>
<p>2，从0到1的能力</p>
<p>3，从1到N的能力</p>
<p>4，团队间的沟通协调能力</p>
<p>5，曾经做过的产品经历</p>
<p>希望后续文章可以分享下具体的案例，如何比较准确评估产品的工期</p>
<ul>
<li>分析市场上某个APP功能的痛点，如何改进，站在用户角度衡量改进那部分，为什么要改，具体是什么功能需要修改</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/11/02/%E6%96%B0%E6%89%8B%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E7%BB%8F%E5%B8%B8%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%8425%E4%B8%AA%E5%9B%B0%E6%83%91/">浅谈新手产品经理常遇到的25个困惑问题。</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2019-11-02</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-09-03</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><strong>①竞品分析的目的有哪些？</strong></p>
<p>论证自己的判断是对的，补充自己的欠缺，知道不知道的。</p>
<p><strong>②在进行从0-1产品规划的时候和进行产品迭代的时候竞品分析的目的有何不同？</strong></p>
<p>0-1的时候主要是看战略，来论证自己做的这个东西是有市场价值、有用户价值的。</p>
<p>迭代时候竞品分析主要是看体验和功能，或者称之为具体的好与坏、对与错。</p>
<p><strong>③竞品分析是如何验证假设的？</strong></p>
<p>说下的理解哦，首先假设的东东是要量化出来的，数量上的具体和每一个的数量上的标准，3条直线、每条直线长度是多少。</p>
<p>然后通过对竞品分析来对比相同度、符合度，借此来证明自己的判断是靠谱可行的，一般是研究比自己好的竞品哦，比自己的差的就很有风险了。</p>
<p><strong>④在竞品选择上是否要根据产品的形态、生命周期、路线规划选取相同阶段、战略定位大致相同的产品分析？</strong></p>
<p>何为竞品？一定是和你有竞争关系的同类产品，用户可以二选一的产品。</p>
<p>产品形态是是首先考虑和花费精力较多的，比如端数 安卓 苹果，pcweb等，还有产品的功能范围和交互体验和视觉选择、信息架构等都是研究的重点，另外竞品研究往往是有一个明确点去研究，很少是全盘研究，至少在大家这个层级，全盘研究是没有意义的。</p>
<p>需要考虑相同阶段，但是往往是不现实的，你刚创立对方已经3年了，同阶段很难。</p>
<p>竞争关系分为 直接竞争、间接竞争、替代性竞争、潜在竞争 体量和你相当、比你大甚至是接近于你。</p>
<p>直接竞争对手，产品相同且满足同样目标人群的同样需求：可口可乐与百事可乐，百度搜索和搜狗搜索</p>
<p>间接竞争对手，产品可能不一样，但是目标人群是一样的：矿泉水与红茶绿茶，都是解决口渴。</p>
<p>替代性竞争对手，目标群体一致，产品或服务有很大的优势能够代替竞争对手：微信的视频语音打电话与 移动联通的电话，微信发消息与短信。</p>
<p>潜在性竞争对手，行业相关的产品，比如纵向的上下游产品，如 顺丰快递与淘宝商城；</p>
<p>非行业相关，比如这几年流行的跨界，传统教培机构、BAT教育平台。</p>
<p><strong>⑤如果在战略和形态上没有相近的竞品在选择潜在竞品、间接竞品时如何保证分析的意义、保证分析的有效性？</strong></p>
<p>不可能没有相近的，只是你没有发现而已；是在没有等量提及的可以考虑模块上的对比，比如跟谁学2015年初的时候 教育界的淘宝，放眼全中国乃至世界是没有竞品的，然后就开始分模块对比了。</p>
<p><strong>⑥在进行产品迭代时候如何搜集用户反馈去除伪需求？</strong></p>
<p>收集用户反馈的途径：产品本身的留言反馈、微博论坛的社交平台舆情监控、微信公众号的留言、如果是B2B产品的话会有客户群和定期拜访计划，如果是2C产品有粉丝群、品类群，当然最重要的是可以定期组织用户见面会，比如京东会定期邀请不同年龄不同性别不同职业不同学历的人做面对面的沙龙访谈。</p>
<p>去除伪需求：首选一定是先多多收集需求、然后对需求进行分析，最后根据人力或者财力等客观限制去对需求分级，最后产出可以做的称之为需求，那些不会去做（现在不去做、或未来也不会去做的）称之为伪需求。但是要知道一点，之所以有伪需求，是因为我们的能力或财力所限制，无法满足对方的要求，才会定义为伪需求。</p>
<p>伪需求一般有几个特征：带有明显主观色彩、缺乏实际的使用场景、投入产出比及其低下、嘴上上说很需要很重要，但不肯付钱购买、无法衡量需求价值、明显不合理、过于小众等。</p>
<p>避免伪需求的常用做法：多看多观察、多用多感受、见多识广、团队讨论，集思广益，感觉是慢慢建立的。</p>
<p>切记一点，伪需求是有时效性的，今天的伪需求在未来1年、3年、5年后可能就是真实的需求了，比如手机可以透明化、手机可以向纸张一样折叠弯曲。</p>
<p><strong>⑦在类似论坛、贴吧这种信息比较多的社区进行用户反馈采集时，如何准确的将信息归类提炼出要点？</strong></p>
<p>方法和前面说的一样，提炼要点是个很主观的定义，不同人不同级别的人、不同职位的人有不同的关注点也会提炼的不一样，但是更多的是用“为用户解决实际问题、帮助用户减少问题、让用户乐意付费、让用户愿意一直不离不弃、让用户愿意向朋友推荐产品”等角度去提炼。</p>
<p><strong>⑧进行迭代时候如何确定需求的重要性、频次，迭代有什么目的？</strong></p>
<p>什么是迭代，一次做不完需要分多次做，才是迭代。尤其是互联网尤其是手机app时代，一般的app每月至少会升级一个新版、很多是每2周升级一个新版，如果你了解开发流程就会发现，2周一个新版，其实留给开发的时间只有4-7天的时间，这几天能写多少代码？所以一次迭代能做多少事情，也是可以衡量出来的。</p>
<p>迭代时确定需求的重要性和公司谈对这个月的目标是紧密联系的，脱离了商业目标的需求是没有重要性的，另外还需要考虑需求的开发周期，2周一上线，需求需要开发5周，那就需要另行讨论了可能重要性也不会高。最后呢 重要性一定是：BUG&gt;&gt;影响付费&gt;&gt;影响客户核心行为&gt;&gt;帮助客户更好&gt;&gt;为更好铺路&gt;&gt;需求价值做与不做的影响。</p>
<p>目的是让用户在最短的时间里用上产品功能并时不时地给用户惊喜，同时在团队力所能及的范围内做更多的事情。</p>
<p><strong>⑨在做产品数据埋点时候需要注意什么？</strong></p>
<p>一定要记录用户身份信息，如果你不说这个要记录用户身份信息，90%的程序员是不会记录的最后你会得到一堆数据，可不知道他们都是谁？和没有数据一样，不知所措。</p>
<p><strong>⑩有什么工具？具体操作流程是什么？数据采集一般都采集哪些标准数据怎么看？</strong></p>
<p>数据埋点工具不是必备，往往在团队精力有限或初期会采用第三方工具，比如友盟，就是不错的工具；比如百度统计和谷歌统计、cnzz等。</p>
<p>具体操作流程根据不同的产品不同的业务要求是很不一样的，埋点是为了业务数据分析而做的，无法一概而论。</p>
<p>一般的流程是，产品经理、数据分析师、业务方碰撞出业务要求，简单来说是 搞明白 为了什么目的？需要用哪些数据？做什么？  然后产品经理评估建立出产品原型或逻辑，定义好指标和关键触发动作、路径然后由研发把他写到代码里。记得记录身份哦。</p>
<p>标准就是依据清晰的业务要求而制定的。这是个业务驱动的行为。</p>
<p>工具或游戏或电商或教育，不同的业务形态是不一样的，比如工具看中的是是用户持续使用、留存，游戏可能看中的是万家付费（这个我不懂，我不玩游戏），电商看中的是用户下单转化率和提升客单价。</p>
<p><strong>①    在进行产品从0-1上线时，MVP小范围验证需求点一般采用什么验证方式？</strong></p>
<p>先让身份的亲人、朋友、同学、同事、群有用用，先圈500人开始用，内测也是个办法。</p>
<p>主要看整个使用的流程是不是通的，比如电商产品无法下单就是不通的、教育产品无法很好的学习就是不通的、不解决实际问题的产品是不同的、大家用完后就不想再来的产品是不通的。</p>
<p>这些都是结果，根据结果反推可以得出问题点，找到了问题点就可以想对策，有了对策就去改 就是迭代也是升级，更是产品的发展。</p>
<p><strong>②    冷启动的用户从哪里来？如何获取种子用户？如何把握迭代周期与频次？</strong></p>
<p>亲人、朋友、同学、同事、同行，100人、500人、1000人、10000人。</p>
<p>目前互联网app时代，迭代的频次基本上是2-4周一次。</p>
<p><strong>③    产品的痛点从哪里来？</strong></p>
<p>产品没有痛点，产品的目标用户才有痛点，产品是为目标用户解决痛点而生的。</p>
<p>痛点是目标用户想要做某件事情/某个行为时，遇到障碍，障碍本身是痛点。</p>
<p><strong>④    用户痛点是自己根据用户场景与竞争市场臆想出来的么？</strong></p>
<p>这个问题其实是很大的问题，臆想、YY肯定是不科学的，往往是不对的。</p>
<p>可通过观察用户、多接触用户观察他们的真实行为，通过观察来记录和抽象，换位思考，自己以真实用户的身份去使用、去行动来发现痛点，多和用户活跃用户交流发现未满足的缺陷，同时也要注意联络哪些已经和你saybyebye的客户，找到他们离开的原因，这些原因往往是你没想到的、也是十分十分重要的。</p>
<p><strong>⑤    在现有市场上如果存在潜在的竞争产品壁垒（比如腾讯已经在某一块做战略布局了）或者已经有成熟的竞争产品那么围绕痛点进行构建差异化、用户卖点这些还有没有意义或者说还有没有必要做新产品？如何把控风险？</strong></p>
<p>这个不是产品经理的考虑范畴、是公司老板的范畴，我没当过老板不敢妄言，但是可以根据自身经历来说一下，如果你想做的事情市面上已经有了，而且和你想做的重复读高达90%的相似，那么你就别做了，除非你是bat、否则很难成功，或者说一定不会成功，比如国民老公的万达，联合腾讯和百度做电商，要钱有钱要人有人、最后还是没听说过，为什么？很重要的一个原因应该是  淘宝京东已经满足目标人群99%的需求了，万达电商没有必要。</p>
<p>除非你能找到差异化，你要么比竞争对手做的好、要么和竞争对手做的不一样（当然得有用哦），只有这样才是可以生存下来的、先生存再发展。</p>
<p><strong>⑥在进行产品收益预估时，如何估计成本与收益？做这些有什么意义（我认为做这些不太准确，且不确定因素过多导致结果误差较大没什么意义）</strong></p>
<p>产品收益其实是产品成败的直观表现，一个产品成功或失败的因素很多很多，产品经理、产品本身只是其中一个因素而已，大家不要高估自己的重要性，当然也没必要低估自己。</p>
<p>但是大家都是在公司里干活，是要花钱的，公司之所以是公司二部是非盈利机构ORG最重要的区别是公司的主要目标是赚钱，此外才是社会责任神马的。所以你做事情要考虑的首要目标是 要么马上赚钱、要么给老板希望未来能赚钱，那么如何赚钱？是你做产品时候需要想明白的，然后要努力去做的。至于是否能做到，不用李军令状，但是想不明白的，基本上肯定做不成。</p>
<p><strong>⑦.看了一些线上课程，听了一些方法论，可是分析具体问题还是停留在很浅显的层面</strong></p>
<p>因为你只是听了，课程其实是  知识和技能的结合体，你看了听了只是接受了这个知识，脑袋里有了印象，缺乏的是动手，只有动手做出来的才算是技能学到了。 知识和技能相结合才会产出能力，你的能力决定了你的发展路线和发展高度。</p>
<p><strong>⑧.写体验报告，竞品分析之类的总套框架，格局看似大但其实内容没有自己的思想，感觉只是翻来覆去说一些表面的东西。</strong></p>
<p>你需要时刻明确牢记，文档和报告的目的是什么，是为了准确无误并且方便地向别人传达你的信息。</p>
<p>至于格式、框架啊都是浮云，当你能够真正将你的信息完整、清晰、准确传达时，无论是ppt还是word甚至是一段语音，都是最好的选择。不要可以去追求表面的东西、实质本身才是最重要的。</p>
<p><strong>⑨对于产品新人来说，每天的学习时间应该怎么分配，是较多精力投入于学课程，看论坛之类 还是留多一些时间思考</strong></p>
<p>如果你是爱读书的人，把京东上产品经理关键词搜索到的图，前20本都读一遍，认真读一遍，读完后你的认知和见解至少比现在高2个层级。</p>
<p>如果不爱读书也没关系，找个产品经理网站，在他上面阅读500篇文章（不要担心500片花费不了你1周的时间），你要认真的读，读完后自己快速会议一篇文章的记忆，并写下来，500篇后，你发认知也会提升2个层级。</p>
<p>思考，是建立在你有足够的见识和认知之上的；如果一个人从来没有见过用过iPhone，再怎么思考也无法提升他在iPhone上的app产品设计能力。</p>
<p>见识是开源，思考是沉淀，足够大的池子才能够沉淀足够多的内涵。</p>
<p>回到题主里看，保持每天读10篇文章、然后多把玩APP、多想想自己最想做什么（要具体的  城市、行业、公司、职位、以及如何达成的路径）。</p>
<p><strong>⑩.想知道像网易，腾讯这样的公司所希望看到的做产品的“潜力”具体是指什么能力呢？有方法进行针对性的训练吗?</strong></p>
<p>潜力，其实可以根据产品经理的能力要求去衡量，似乎是个可以量化的要求，比如产品经理需要：市场能力（商务沟通能力、市场分析能力、商业前瞻能力）、产品能力（用户调研、需求抽象、产品规划、结果导向、成本意识、专业设计）运营能力（数据分析、危机预测、营销推广）、关键能力（沟通、行业融入、技术理解、心态性格）领导能力（项目管理、教练、领袖、老大）等。</p>
<p>人生处处皆学问、所见所遇皆产品，可以试着从某个能力上开始可以联系，逐步提升。具体的联系步骤这里就不细讲了，大家可以自己动手搜索、或者我们私聊哈。</p>
<p><strong>①.    在笔试或面试时，如果碰到毫无头绪的题目比如“世界上有多少个钢琴调音师”这种题，完全没有思路，应该怎么办呢？</strong></p>
<p>这个主要看面试官是在什么场景下提出的吧。很多事情这类题并不是要你的具体答案，而是要看你寻找答案的过程、你的反应、你的做法、你的考虑、以及你为何会这样做。甚至还有可能是压力测试。</p>
<p>问你这个问题的面试官，应该是和音乐或钢琴相关的公司吧。</p>
<p><strong>②，平时如何开脑洞发现当前未解决的需求痛点？有什么渠道？</strong></p>
<p>首先要聚焦到行业、甚至是公司的某个产品，然后才能持续多跟踪对比和深入的研究调查、接触用户，才能发现需求痛点。抛开行业就不存在痛点了。</p>
<p>要明白一点，产品是要解决某些人群的共性问题，解决这个共性问题就是产品的定位，而不是要解决全中国14亿人的方方面面的问题，那样的产品不存在。</p>
<p><strong>③现在哪类产品（app）容易被推广且受到欢迎？</strong></p>
<p>容易被推广和受欢迎是相对的，如果不对比我只能说色情网站是最容易且最受欢迎的，可惜在中国这个是违法犯罪。</p>
<p>言归正传，就我所经历的来看，娱乐类的app会更容易被推广、大家也都会收欢迎，毕竟生活很苦很累都想乐呵下，具体到产品形态的话，短视频、短音频似乎是个不错的方向。</p>
<p>从整体大环境上看，app已经开始向超级app集中转移，但是人们还是喜欢说 小而美最好。</p>
<p>只要你的产品能很好的、简单地彻底的帮用户解决棘手的问题、刚需的问题，你的产品就会有好口碑，推广都是顺势而为的事情。如果产品自身不行，及时通过推广引来了用户，你也接不住，用户还是要流失的。</p>
<p>所以我们不能本末倒置，不要为了迎合好推广而却做产品，应该是做了好产品再去做好推广。</p>
<p><strong>④产品小白求职中，需要额外准备哪些产品相关技能？HR更看重啥？</strong></p>
<p>不同行业不同公司不同HR本人是不同的要求，对于0基础的同学我个人认为 态度、好学和综合素养比产品技能更重要。</p>
<p>HR更看重啥，HR更看重你要钱少、性价比高。</p>
<p>如果说一定要准备一些产品技能的话，可以考虑 言谈沟通能力、书面答题表达能力、行业认知见识面、个人爱好潜力（一定是有利于公司产品的爱好潜力）、做过一些案例也是极好的。</p>
<p><strong>⑤.做产品经理需要懂技术吗？如果需要的话，要懂到什么程度呢？</strong></p>
<p>个人认为，需要技术。因为产品经理60%的时间会和技术打交道，试想一下，如果彼此没有一点儿共性认知，那是何等痛苦；另外不懂技术的产品经理往往会提出很多没法实现的需求，一次两次三次，之后大家怎么愉快地合作呢？</p>
<p>所以说，产品经理懂点技术是好的。</p>
<p>根据不同的方向的产品经理对技术的要求不一样，比如做2C的产品，知道技术皮毛即可、但是做云计算底层仓库的产品经理，一般都要求是技术、架构师出身。</p>
<p>一般来讲，懂到什么程度呢？  HTML看一遍、会用HTML写网页；SQL语言学一遍，日常常用的增删改查代码能看懂；计算机程序设计（比如java、php、javascript等）入门懂一点，达到听说过、有印象的水平即可，这方面计算机毕业的同学有优势。</p>
<p>当然，这些都是有了、懂了会更好，不会也没关系，毕竟产品经理岗位的主要目的不是为了写代码。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2017/10/02/1490409097.384878/">数据库基本操作命令（基础）</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2017-10-02</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-09-03</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>创建一个用户，只许本地登录</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user &#39;fanxiao2&#39;@&#39;127.0.0.1&#39; identified by &#39;123456&#39;</span><br></pre></td></tr></table></div></figure>
<p>分配给用户操作数据库的权限</p>
<p>为fanxiao2这个用户分权所有权限，这个权限只能用在fanxiao2这个数据库的所有数据表上</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on fanxiao2.* to fanxiao2@127.0.0.1;</span><br></pre></td></tr></table></div></figure>

<p>让权限生效</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></div></figure>

<p>找出在Mysql这个数据里的user这个表里边的user字段里的所有信息</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user form mysql.user</span><br></pre></td></tr></table></div></figure>

<p>查看mysql数据库里边user数据表里边的所有字段</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desc mysql.user;</span><br><span class="line"></span><br><span class="line">select user, host, password form mysql.user;</span><br></pre></td></tr></table></div></figure>

<p>查看Mysql数据表里用户的权限</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user, select_priv form mysql.user;</span><br></pre></td></tr></table></div></figure>

<p>查看特定数据表里用户的权限</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user, db, select_priv form mysql.db;</span><br></pre></td></tr></table></div></figure>

<p>查询fanxiao2 这个用户被授予的所有数据库权限</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show grants for fanxiao2@127.0.0.1</span><br></pre></td></tr></table></div></figure>

<p>吊销fanxiao2 这个用户的某些权限</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke update, delete on fanxiao2.* from fanxiao2@127.0.0.1;</span><br></pre></td></tr></table></div></figure>

<p>执行完命令之后可以查看当前所拥有的权限</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user, db, update_priv, delete_priv from mysql.db;</span><br></pre></td></tr></table></div></figure>

<p>为fanxiao2这个用户设置一个新的密码</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set password for fanxiao2@127.0.0.1 &#x3D; password(&#39;toor&#39;);</span><br></pre></td></tr></table></div></figure>

<p>删除用户</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop user fanxiao2@127.0.0.1;</span><br></pre></td></tr></table></div></figure>

<p>创建数据</p>
<p>show databases; 查看数据库</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create database fanxiao2;</span><br><span class="line">或者</span><br><span class="line">create database if not exists fanxiao2; </span><br></pre></td></tr></table></div></figure>

<p>这条命令会返回创建数据库是出现的错误<br>删除数据库</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database fanxiao2;</span><br></pre></td></tr></table></div></figure>

<p>创建数据表</p>
<p>先创建一个范小二数据库</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database fanxiao2;</span><br></pre></td></tr></table></div></figure>

<p>切换到范小二数据库里</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use fanxiao2;</span><br></pre></td></tr></table></div></figure>

<p>查看数据表</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></div></figure>
<p>创建数据表</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table users(</span><br><span class="line">    username int(11),</span><br><span class="line">    password varchar(255),</span><br><span class="line">);</span><br></pre></td></tr></table></div></figure>

<p>添加数据表中的数据栏</p>
<p>新添加的数据栏会出现在数据表的最前面</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table users add id INT(11) first;</span><br></pre></td></tr></table></div></figure>

<p>添加数据栏让它出现在password数据栏的下面</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table users add username TEXT after password;</span><br></pre></td></tr></table></div></figure>

<p>添加id数据栏为主键</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table users add PRIMARY KEY (id);</span><br></pre></td></tr></table></div></figure>

<p>修改数据栏(修改数据栏中id为user_id)</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table users change id user_id INT(11);</span><br></pre></td></tr></table></div></figure>

<p>修改数据表名字</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table users rename to fanxiao2user;</span><br></pre></td></tr></table></div></figure>

<p>删除数据栏</p>
<p>删除fanxiao2user 这个数据表中的username 数据栏</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table fanxia2user drop username;</span><br></pre></td></tr></table></div></figure>

<p>新建一个测试</p>
<p>重新创建一个数据库</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database xiao2 charset&#x3D;utf8;</span><br></pre></td></tr></table></div></figure>

<p>进入数据库</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use xiao2</span><br></pre></td></tr></table></div></figure>

<p>创建数据表并添加字段</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table users(</span><br><span class="line">    user_id INT(11) unsigned not null auto_increment,</span><br><span class="line">    username VARCHAR(100),</span><br><span class="line">    userpass VARCHAR(255),</span><br><span class="line">    primary key(user_id)</span><br><span class="line">)default charset&#x3D;utf8;</span><br></pre></td></tr></table></div></figure>

<p>查看表字段</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe users;</span><br></pre></td></tr></table></div></figure>

<p>插入数据记录</p>
<p>进入数据表</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use users;</span><br></pre></td></tr></table></div></figure>

<p>插入数据</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert init users values(null, &#39;fanxiao2&#39;, &#39;123456&#39;);</span><br></pre></td></tr></table></div></figure>

<p>插入数据表具体的栏</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into users (username, userpass) values (&#39;fanxiao2test&#39;, &#39;12345678&#39;);</span><br></pre></td></tr></table></div></figure>

<p>查询数据</p>
<p>查看所有的数据记录</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users;</span><br></pre></td></tr></table></div></figure>

<p>指定查询某个字段数据</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select username from users;</span><br></pre></td></tr></table></div></figure>

<p>限制查询条件</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where username &#x3D; &#39;fanxiao2&#39;;</span><br></pre></td></tr></table></div></figure>

<p>查询数据后按照排序显示</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from users order by username desc;(升序排序)</span><br><span class="line">select * from users order by username asc;(降序排序)</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2017/08/25/1490409059.353015/">php核心技术与最佳实现</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2017-08-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-09-03</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>类和对象的关系理解：</p>
<blockquote>
<p>对象是数据，对象本身不包含 方法。但是对象有一个指针指向一个类，这个类里可以有方法。</p>
</blockquote>
<p>类和对象是不可分割的，有对象就必定有一个类和其对应，否则这个对象也就成 了没有亲人的孩子（但有一个特殊情况存在，就是由</p>
<p>标量进行强制类型转换的object,没有一个类和它对应。此时php中一个称为“孤儿”的stdClass类就会收留这个对象。</p>
<p>类的组合与继承</p>
<p>在一份代码清单里，定义了两个类，一个是person,一个是family;在family类中创建person类的对象，并把这个对象视为family类的</p>
<p>一个属性，并调用它的方法处理问题，这种复用方法叫做“组合”，还有一个复用方式，就是继承。</p>
<blockquote>
<p>耦合：一个软件结构内不同模块之间互联程度的度量，也就是不同模块之间的依赖关系。</p>
</blockquote>
<p>低耦合：指模块与模块之间，尽可能地各个模块独立；模块与模块之间的接口尽量少而简单。</p>
<p>解耦：要解除模块与模块之间的依赖。</p>
<p>组合和继承两者有很高的相似度，在两者皆可用的情况下，更倾向于使用组合。为啥呢？</p>
<p>继承破坏封装性</p>
<p>鸟类是父类，鸭子继承鸟类，鸭子岂不是会飞了？组合，从语义上来说，要优于继承。</p>
<p>继承是紧耦的</p>
<p>子类与父类捆绑在一起。组合仅通过唯一接口和外部进行通信，耦合度低于继承。</p>
<p>继承扩展复杂</p>
<blockquote>
<p>多层继承和子类的增加，将设计大量方法重写。</p>
</blockquote>
<p>不恰当地使用继承可能违反现实世界中的逻辑</p>
<blockquote>
<p>组合并非没有缺点，在创建对象时，组合需要一一创建局部对象，这一定程度上增加了一些代码。</p>
</blockquote>
<p>显然组合增加了代码量，组合还有其他缺点，不过总体来说，是优点大于缺点。</p>
<p>PHP5对面向对象的特性做了许多增强，其中就有一个SPL(标准PHP库）的尝试。SPL中定义了一些接口，其中最主要的就是</p>
<blockquote>
<p>Iterator迭代器接口，通过实现这个接口，就能使对象能够用于foreach结构，从而在使用形式上比较统一。</p>
</blockquote>
<blockquote>
<p>实现Iterator的类，必须实现Iterator接口定义的五个方法current,key,next,rewind,valid</p>
</blockquote>
<p>接口是对多重继承的一种变相实现，而在讲继承时，我们提到了用来实现混入氏的Traits,实际上，Traits可以被视为一种加强型的接口。</p>
<p>Traits和接口很像，Traits是可以被导入的（use语法），且已经实现了的方法列表。</p>
<p>反射</p>
<blockquote>
<p>面向对象编程中对象被赋予了自省的能力，而这个自省的过程就是反射。</p>
</blockquote>
<p>反射，直观理解就是根据到达地找到出发地和来源。比方说，我给你一个光秃秃的对象，我可以仅仅通过这个对象就能知道它所属的类，拥有哪些方法。</p>
<blockquote>
<p>反射指在PHP运行状态中，扩展分析php程序，导出或提取出关于类、方法、属性、参数等的详细信息，包括注释。这种动态获取信息以及动态调用对象方法的功能称为反射API.</p>
</blockquote>
<p>来个实例看看：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class person&#123;</span><br><span class="line"></span><br><span class="line">public $name;</span><br><span class="line"></span><br><span class="line">public $gender;</span><br><span class="line"></span><br><span class="line">public function say()&#123;</span><br><span class="line"></span><br><span class="line">echo $this-&gt;name,&quot;\tis &quot;,$this-&gt;gender,&quot;\r\n&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function __get($name)&#123;</span><br><span class="line"></span><br><span class="line">if(!isset($this-&gt;$name))&#123;</span><br><span class="line"></span><br><span class="line">echo &#39;未设置&#39;;</span><br><span class="line"></span><br><span class="line">$this-&gt;$name&#x3D;&quot;正在为你设置默认值&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return $this-&gt;$name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$student &#x3D; new person();</span><br><span class="line"></span><br><span class="line">$student-&gt;name&#x3D;&#39;Tom&#39;;</span><br><span class="line"></span><br><span class="line">$student-&gt;gender&#x3D;&#39;male&#39;;</span><br><span class="line"></span><br><span class="line">$student-&gt;age&#x3D;24;</span><br></pre></td></tr></table></div></figure>

<p>现在要获取这个student对象的方法和属性列表该怎么做呢？如下代表所示：</p>
<p>//获取对象属性列表</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$reflect &#x3D; new ReflectionObject($student);</span><br><span class="line"></span><br><span class="line">$props &#x3D; $reflect-&gt;getProperties();</span><br><span class="line"></span><br><span class="line">foreach($props as $prop)&#123;</span><br><span class="line"></span><br><span class="line">print $prop-&gt;getName().&quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>//获取对象方法列表</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$m &#x3D; $reflect-&gt;getMethods();</span><br><span class="line"></span><br><span class="line">foreach($m as $prop)&#123;</span><br><span class="line"></span><br><span class="line">print $prop-&gt;getName().&quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>也可以不用反射API,使用class函数，返回对象属性的关联数组以及更多信息：</p>
<p>//返回对象属性的关联数组</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_dump(get_object_vars($student));</span><br></pre></td></tr></table></div></figure>

<p>//类属性</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_dump(get_class_vars(get_class($student)));</span><br></pre></td></tr></table></div></figure>

<p>//返回由类的方法名组成的数组</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_dump(get_class_methods(get_class($student)));</span><br></pre></td></tr></table></div></figure>

<p>反射API的功能显示更强大，甚至能还原这个类的原型，包括方法的访问权限。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">$obj &#x3D; new ReflectionClass(&#39;person&#39;);</span><br><span class="line"></span><br><span class="line">$className &#x3D; $obj-&gt;getName();</span><br><span class="line"></span><br><span class="line">$Methods &#x3D; $Properties &#x3D; array();</span><br><span class="line"></span><br><span class="line">foreach($obj-&gt;getProperties() as $v)&#123;</span><br><span class="line"></span><br><span class="line">$Properties[$v-&gt;getName()] &#x3D; $v;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach($obj-&gt;getMethods() as $v)&#123;</span><br><span class="line"></span><br><span class="line">$Methods[$v-&gt;getName()] &#x3D; $v;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;class &#123;$className&#125;\n &#123; \n&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ksort多用于给关联数组排序</span><br><span class="line"></span><br><span class="line">is_array($Properties) &amp;&amp; ksort($Properties);</span><br><span class="line"></span><br><span class="line">foreach($Properties as $k &#x3D;&gt; $v)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">echo &quot;\t&quot;;</span><br><span class="line"></span><br><span class="line">echo $v-&gt;isPublic() ? &#39;public&#39;:&#39;&#39;,$v-&gt;isPrivate()?&#39;private&#39;:&#39;&#39;,</span><br><span class="line"></span><br><span class="line">$v-&gt;isProtected()  ? &#39;protected&#39;:&#39;&#39;,</span><br><span class="line"></span><br><span class="line">$v-&gt;isStatic() ? &#39;static&#39;:&#39;&#39;;</span><br><span class="line"></span><br><span class="line">echo &quot;\t&#123;$k&#125;\n&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">if(is_array($Methods)) ksort($Methods);</span><br><span class="line"></span><br><span class="line">foreach($Methods as $k&#x3D;&gt;$v)&#123;</span><br><span class="line"></span><br><span class="line">echo &quot;\tfunction &#123;$k&#125;()&#123;&#125;\n&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;&#125; \n&quot;;</span><br><span class="line"></span><br><span class="line">输出的结果是什么？</span><br><span class="line"></span><br><span class="line">class person</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public gender</span><br><span class="line"></span><br><span class="line">public name</span><br><span class="line"></span><br><span class="line">function __get()&#123;&#125;</span><br><span class="line"></span><br><span class="line">function __set()&#123;&#125;</span><br><span class="line"></span><br><span class="line">function say()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>反射有什么用？</p>
<blockquote>
<p>反射可以用于文档生成。因此可以用它对文件里的类进行扫描，逐个生成描述文档。</p>
</blockquote>
<p>既然反射可以探知类的内部结构，那么是不是可以用它做Hook实现插件功能呢？或者是做动态代理呢？</p>
<p>&lt;?php</p>
<p>class mysql {</p>
<p>function connect($db){</p>
<p>echo “连接到数据库${db[0]} \r\n”;</p>
<p>}</p>
<p>}</p>
<p>class sqlproxy{</p>
<p>private $target;</p>
<p>function  __construct($tar){</p>
<p>$this-&gt;target[] = new $tar();</p>
<p>}</p>
<p>function __call($name,$args){</p>
<p>foreach($this-&gt;target as $obj){</p>
<p>//$obj是一个对象而不是类，但是这里也可以是ReflectionClass反射API</p>
<p>$r = new ReflectionClass($obj);</p>
<p>if($method = $r-&gt;getMethod($name)){</p>
<p>if($method -&gt;isPublic() &amp;&amp; !$method-&gt;isAbstract()){</p>
<p>echo “方法前拦截记录Log \r\n”;</p>
<p>$method-&gt;invoke($obj,$args);</p>
<p>echo “方法后拦截\r\n”;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>$obj = new sqlproxy(‘mysql’);</p>
<p>$obj-&gt;connect(‘member’);</p>
<blockquote>
<p>这里简单说明一下，真正的操作类是mysql类，但是sqlproxy类实现了根据动态传入参数，代替实际的类执行，并且在方法运行前后进行拦截（这就是TP中before，after方法或者laravel框架中中间件的实现原理），并且动态地改变类中的方法和属性。这就是简单的动态代理。</p>
</blockquote>
<p>在平常开发中，用到反射的地方不多：一个是对对象进行调试，另一个是获取类的信息。在MVC和插件开发中，使用反射很常见，但是反射的消耗也大，在可找到替代方案的情况下，就不要滥用。</p>
<blockquote>
<p>php有Token函数，可以通过这个机制实现一些反射功能。从简单灵活的角度讲，使用已经提供的反射API是可取的。</p>
</blockquote>
<p>很多时候，善用反射能保持代码的优雅和简洁，但反射也会破坏类的封装性，因为反射可以使本不应该暴露的方法或属性暴露了出来，这既是优点也是缺点。</p>
<p>思考：为什么使用反射，反射存在的必要性是什么？或者说，反射为什么会存在？</p>
<p>缓存</p>
<p>缓存，最初在学操作系统的时候，有这方面的知识。这里来个更抽象的。</p>
<blockquote>
<p>只要两种介质之间存在传输速率差，速率较高的一方即可作为对应的缓存。自底向上，可以简单认为，计算机系统中每一层的速率相差一个数量级（如CPU的响应速率是内存的10倍，内存则是硬盘的10倍等）的都会使用Cache.</p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2017/08/22/1490408992.038417/">如何搭建一个Ghost平台博客</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2017-08-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-09-03</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h4 id="用的是一键安装脚本"   >
          <a href="#用的是一键安装脚本" class="heading-link"><i class="fas fa-link"></i></a>用的是一键安装脚本</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;7xjooa.dl1.z0.glb.clouddn.com&#x2F;install.sh &amp;&amp; chmod 755 install.sh &amp;&amp; .&#x2F;install.sh</span><br></pre></td></tr></table></div></figure>

<p>在shell终端执行这个脚本，中间会让输入三次，第一次域名，第二次mysql数据库root的密码，第三次mysql数据库ghost的密码。</p>
<p>安装完成后输入你的域名/ghost设置管理员信息即可（域名记得要解析）。</p>
<p>我刚好搭了一个自己的个人博客，主机买的是阿里云的，域名在万网直接买的。</p>
<p>看样子题主还是个一无所知的小白，那刚好我也在这里总结下我自己的搭建Ghost博客的过程吧。</p>
<p>服务器篇：<br>服务器的选择比较广，关于服务器的选择国内国外的争论在此不提。</p>
<p>记住一点：国内主机解析域名需备案！</p>
<p>服务器的系统：Ubuntu14.04 64位。</p>
<p>域名篇：<br>域名的话和服务器一样，购买选择比较宽泛，建议直接国内万网得了，省事。<br>再买完服务器以后，阿里云的首页就会有“万网”的链接，直接跳转过去购买，淘宝一样的操作，不多讲。</p>
<p>域名解析：<br>在购买完域名和服务器以后呢，就可以在阿里云服务器控制台进行解析。进入阿里云控制台以后，就可以直接看到，这里不是重点，就不讲了。</p>
<p>备案篇：<br>阿里云的备案服务还是很好的，和在淘宝购物一般，一切都可以线上完成，无脑，只需要耐心等待审批过程。<br>备案服务也在控制台里可以看见。</p>
<p>工具篇：<br>有了以上这些东西，为了方便使用阿里云主机，请下载Xshell，Xftp两个工具。<br>这连个工具全部免费，网上使用教程也满天飞，在此不多说。</p>
<p>————————————————-重点来了———————————————-</p>
<p>现在已经有了阿里云的主机，解析了服务器，阿里云的主机系统也选择好了（Ubuntu14.04 64位）</p>
<p>Step1 基础配置：<br>Ghost是依托于node.js的，所以要先搭建node环境。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install -y python-software-properties python g++ make  </span><br><span class="line">sudo add-apt-repository ppa:chris-lea&#x2F;node.js  </span><br><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install nodejs  </span><br></pre></td></tr></table></div></figure>
<p>这些命令全部执行完毕以后，要确认是否配置成功。在终端输入：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">v0.10.36</span><br></pre></td></tr></table></div></figure>
<p>显示node的版本号，即为安装成功。</p>
<p>接下来再确认一下npm安装是否成功，终端输入：<br>npm -v<br>同样，输出版本号为安装成功。</p>
<p>Step2配置Ghost：<br>首先要新建一个工作空间（文件夹）来存放Ghost：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;var&#x2F;www&#x2F;</span><br></pre></td></tr></table></div></figure>

<p>下载Ghost：</p>
<p>进入刚才创建的工作空间<br>cd /var/www/<br>下载Ghost并解压</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https:&#x2F;&#x2F;ghost.org&#x2F;zip&#x2F;ghost-latest.zip</span><br><span class="line">sudo unzip -d ghost ghost-latest.zip</span><br></pre></td></tr></table></div></figure>

<p>(解压的时候可能会出错，是因为没有下载解压工具unzip，执行命令下载即可，然后重复解压命令。)</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install unzip</span><br></pre></td></tr></table></div></figure>

<p>安装Ghost的生产模块：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ghost&#x2F;</span><br><span class="line">sudo npm install --production</span><br></pre></td></tr></table></div></figure>

<p>现在我们已经安装完了，但是需要设置之后，才能启动它。</p>
<p>Ghost设置：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp config.example.js config.js</span><br></pre></td></tr></table></div></figure>

<p>这句话的意思复制config.example.js 并命名为config.js，我们要对config.js这个文件进行修改：<br>sudo nano config.js</p>
<p>(这句话是用nano打开config.js，提示没有安装nano的话，输入以下命令安装，然后重复上一条命令：)</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nano</span><br></pre></td></tr></table></div></figure>

<p>打开以后，修改以下被标注的区域：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">config &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; ### Production</span><br><span class="line">    &#x2F;&#x2F; When running Ghost in the wild, use the production environment</span><br><span class="line">    &#x2F;&#x2F; Configure your URL and mail settings here</span><br><span class="line">    production: &#123;</span><br><span class="line">        url: &#39;http:&#x2F;&#x2F;my-ghost-blog.com&#39;,</span><br><span class="line">###将‘  ’内部的内容修改为你的解析后的域名，注意带上http</span><br><span class="line">        mail: &#123;</span><br><span class="line">            &#x2F;&#x2F; Your mail settings</span><br><span class="line">        &#125;,</span><br><span class="line">        database: &#123;</span><br><span class="line">            client: &#39;sqlite3&#39;,</span><br><span class="line">            connection: &#123;</span><br><span class="line">                filename: path.join(__dirname, &#39;&#x2F;content&#x2F;data&#x2F;ghost.db&#39;)</span><br><span class="line">            &#125;,</span><br><span class="line">            debug: false</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        server: &#123;</span><br><span class="line">            &#x2F;&#x2F; Host to be passed to node&#39;s &#96;net.Server#listen()&#96;</span><br><span class="line">            host: &#39;127.0.0.1&#39;,</span><br><span class="line">###将‘127.0.0.1’改为‘0.0.0.0’</span><br><span class="line">            &#x2F;&#x2F; Port to be passed to node&#39;s &#96;net.Server#listen()&#96;, for iisnode s$</span><br><span class="line">            port: &#39;2368&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">(...)</span><br></pre></td></tr></table></div></figure>

<p>然后CTRL + X再输入Y然后敲ENTER退出。</p>
<p>现在已经配置好了Ghost，输入：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm start --production</span><br></pre></td></tr></table></div></figure>

<p>大概会显示：</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   href="mailto:&#103;&#104;&#x6f;&#x73;&#x74;&#64;&#48;&#x2e;&#54;&#x2e;&#x34;" >&#103;&#104;&#x6f;&#x73;&#x74;&#64;&#48;&#x2e;&#54;&#x2e;&#x34;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> start /var/www/ghost<br>node index</p>
</blockquote>
<p>Migrations: Database initialisation required for version 003<br>Migrations: Creating tables…<br>Migrations: Creating table: posts</p>
<p>[…]<br>然后现在你就可以让你的Ghost使用2368这个端口：http://你的域名.com:2368就可以看到Ghost本尊。</p>
<p>CTRL + C可以结束掉正在开启的Ghost</p>
<p>但是这还不是结束！<br>接下来要让你的Ghost一直处于运行状态。</p>
<p>Step4 配置服务器程序：<br>在终端执行：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></div></figure>

<p>接下来需要对Nginx进行一些配置：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br><span class="line">sudo rm sites-enabled&#x2F;default</span><br><span class="line">sudo touch &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;ghost</span><br><span class="line">sudo nano &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;ghost</span><br></pre></td></tr></table></div></figure>

<p>然后把这些代码粘贴进去：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name your_domain.tld;</span><br><span class="line">###修该为你的域名</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_set_header   X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header   Host      $http_host;</span><br><span class="line">        proxy_pass         http:&#x2F;&#x2F;127.0.0.1:2368;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>然后建立一个链接，将你新建的配置告诉Nginx：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;ghost &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;ghost</span><br></pre></td></tr></table></div></figure>

<p>然后重启Nginx：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></div></figure>

<p>接下来创建一个新的用户，并给与他权限：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser --shell &#x2F;bin&#x2F;bash --gecos &#39;Ghost application&#39; ghost</span><br><span class="line">sudo chown -R ghost:ghost &#x2F;var&#x2F;www&#x2F;ghost&#x2F;</span><br></pre></td></tr></table></div></figure>

<p>然后用ghost用户使用系统：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - ghost</span><br></pre></td></tr></table></div></figure>

<p>现在我们要开启Ghost：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;www&#x2F;ghost</span><br><span class="line">npm start --production</span><br></pre></td></tr></table></div></figure>

<p>然后你可以在浏览器输入你的域名来查看你的Ghost博客。</p>
<p>Step5 保持Ghost的运行：<br>我们得先退出ghost用户：<br>exit<br>接下来安装forever：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g forever</span><br></pre></td></tr></table></div></figure>

<p>然后执行：<br>NODE_ENV=production forever start index.js<br>接下来看一下forever是否挂在了index.js：<br>forever list<br>这个状态的话，你就可以开始你的Ghost之路了！</p>
<p>结束进程命令：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forever index.js</span><br></pre></td></tr></table></div></figure>


</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2017/08/18/1490408937.581689/">自动脚本安装</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2017-08-18</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-09-03</span></span></div></header><div class="post-body"><div class="post-excerpt"><p> Docker 官网为了简化安装流程，提供了一套安装脚本，Ubuntu和Debian系统可以使用这套脚本进行安装</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https:&#x2F;&#x2F;get.docker.com&#x2F; | sh</span><br></pre></td></tr></table></div></figure>

<p> 执行这个命令后，脚本就会自动的将一切准备工作做好，并把Docker install 系统中；不过在国内咱们要考虑的问题自然是 墙(翻墙安装); 如果没有翻墙条件的朋友建议使用阿里提供的安装脚本</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sS http:&#x2F;&#x2F;acs-public-mirror.oss-cn-hangzhou.aliyuncs.com&#x2F;docker-engine&#x2F;internet | sh -</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h4 id="手动安装需要的软件包"   >
          <a href="#手动安装需要的软件包" class="heading-link"><i class="fas fa-link"></i></a>手动安装需要的软件包</h4>
      <p>从14.04以后开始，一部分的内核模块转移到了可选内核模块包（linux-image-extra-*） ,以减少内核软件包的体积。正常安装系统应该会包含可选内核模块包，而一些裁剪后的系统可能会将其精简掉。AUFS 内核模块的一部分，作为推荐的Docker存储驱动，一般建议安装可选内核模块包以使用AUFS。</p>
<p>我用的Ubunut:16.04 选择如下命令install</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install linux-image-extra-$(uname -r)linux-image-extra-virtual</span><br></pre></td></tr></table></div></figure>


        <h4 id="添加APT镜像源"   >
          <a href="#添加APT镜像源" class="heading-link"><i class="fas fa-link"></i></a>添加APT镜像源</h4>
      <p>虽然Ubuntu 系统软件源中有Docker 名为 docker.io 但是这个版本太旧。我们需要Docker官网提供的软件源</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates</span><br></pre></td></tr></table></div></figure>
<p>为了确认所下载软件包的合法性,需要添加Docker 官网软件源的GPG密钥</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv \</span><br><span class="line">               --keyserver hkp:&#x2F;&#x2F;ha.pool.sks-keyservers.net:80 \</span><br><span class="line">               --recv-keys 58118E89F3A912897C070ADBF76221572C52609D</span><br></pre></td></tr></table></div></figure>

<p>然后我们需要向 source.lost中添加Docker软件源,下列表中列出了不同的APT源.</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">替换source.list （将其中的 &lt;REPO&gt; 替换为上表的值）:</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;REPO&gt;&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list</span><br></pre></td></tr></table></div></figure>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Precise 12.04 (LTS)	deb https:&#x2F;&#x2F;apt.dockerproject.org&#x2F;repo ubuntu-precise main</span><br><span class="line">Trusty 14.04 (LTS)	deb https:&#x2F;&#x2F;apt.dockerproject.org&#x2F;repo ubuntu-trusty main</span><br><span class="line">Wily 15.10	deb https:&#x2F;&#x2F;apt.dockerproject.org&#x2F;repo ubuntu-wily main</span><br><span class="line">Xenial 16.04 (LTS)	deb https:&#x2F;&#x2F;apt.dockerproject.org&#x2F;repo ubuntu-xenial main</span><br></pre></td></tr></table></div></figure>

<p><img src="http://devon.oss-cn-hangzhou.aliyuncs.com/others/erpo.png" alt="ERPO"></p>
<p>添加成功后,更新apt软件包缓存</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></div></figure>


        <h4 id="安装Docker"   >
          <a href="#安装Docker" class="heading-link"><i class="fas fa-link"></i></a>安装Docker</h4>
      <p>一切准备就绪后就可以安装最新版本的Docker了 ,软件包名称为 docker-engine</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker-engine</span><br></pre></td></tr></table></div></figure>

<p>启动引擎</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line">16.04</span><br><span class="line"></span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></div></figure>


        <h4 id="建立一个用户组"   >
          <a href="#建立一个用户组" class="heading-link"><i class="fas fa-link"></i></a>建立一个用户组</h4>
      <p>默认情况下 docker 命令会使用Unix socket 与 Docker 引擎通讯. 而只有root 用户和docker 组的用户才可以访问Docker引擎的unix socket。 为了安全考虑 一般不会直接使用root用户，所以需使用docker的用户加入docker 用户组</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></div></figure>

<p>将当期用户加入docker组</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker devon</span><br></pre></td></tr></table></div></figure>



</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2017/08/11/1490408832.055190/">热更新</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2017-08-11</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-09-03</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Docker-Swarm：创建服务器集群"   >
          <a href="#Docker-Swarm：创建服务器集群" class="heading-link"><i class="fas fa-link"></i></a>Docker Swarm：创建服务器集群</h1>
      <blockquote>
<p>Docker Swarm 是创建服务器集群用的工具。把一堆服务器绑到一块儿用，让它们看起来像是一台服务器，通过统一的接口在这些服务器上运行应用。<br>集群里的服务器之间相互知道彼此，它们也知道哪些服务器上运行了什么样的服务，如果访问的服务在服务器上不存在，它会把访问转移到集群里的正确的服务器上去处理。一个服务可以用多个容器来支持，这些容器运行在集群里的不同的服务器上，请求可以均衡的分布给这些容器。当有服务器挂掉以后，在它上面运行的服务会被转移到其它的服务器上运行。<br>Docker Swarm 只需要几行命令就可以为应用创建一个强大的集群，为你的应用提供高可用的服务。</p>
</blockquote>

        <h4 id="模拟集群环境"   >
          <a href="#模拟集群环境" class="heading-link"><i class="fas fa-link"></i></a>模拟集群环境</h4>
      <blockquote>
<p>如果你已经有了几台服务器，安装 Docker 以后就可以去创建一个服务器集群了，如果你想在本地测试 Docker Swarm 的功能，可以模拟一个集群环境，也就是在本地创建几台 Linux 系统的虚拟机，安装 Docker ，配置集群。下面介绍使用 Vagrant 创建虚拟机的方法。<br>1.安装 Virtualbox：虚拟机软件 2.安装 Vagrant：管理虚拟机用的工具，它可以管理 Virtualbox 虚拟机 3.安装 Vagrant Hostmanager 插件<br>Windows 如果启用了 Hyper-v 以后，就不能再使用 Virtualbox 或者其它的虚拟软件了。<br>Vagrant Hostmanager 是 Vagrant 的一个插件，设置了虚拟机的主机名以后，这个插件可以帮助我们设置虚拟机中的 /etc/hosts 文件，在里面添加正确的主机记录，这样如果创建了多台虚拟机，这些虚拟机之间可以使用虚拟机的主机名来访问到对方，这个插件并不是必须的，不过它很有用，它也可以设置本地主机上的 hosts 文件，这样你在本地主机上也可以直接使用虚拟机的主机名来访问到它。</p>
</blockquote>

        <h4 id="创建项目目录"   >
          <a href="#创建项目目录" class="heading-link"><i class="fas fa-link"></i></a>创建项目目录</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;Users&#x2F;devon&#x2F;docker&#x2F;</span><br><span class="line">mkdir docker-swarm</span><br><span class="line">cd docker-swarm</span><br></pre></td></tr></table></div></figure>


        <h4 id="初始化项目，使用-centos-7-这个-box"   >
          <a href="#初始化项目，使用-centos-7-这个-box" class="heading-link"><i class="fas fa-link"></i></a>初始化项目，使用 centos/7 这个 box</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant init centos&#x2F;7</span><br></pre></td></tr></table></div></figure>


        <h4 id="用编辑器打开项目目录"   >
          <a href="#用编辑器打开项目目录" class="heading-link"><i class="fas fa-link"></i></a>用编辑器打开项目目录</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atom .&#x2F;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>编辑一下项目根目录下的 Vagrantfile，替换成下面的代码，它可以创建三台虚拟机，test1，test2，test3。</p>
</blockquote>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(2) do |config|</span><br><span class="line"></span><br><span class="line">  config.vm.box &#x3D; &quot;centos&#x2F;7&quot;</span><br></pre></td></tr></table></div></figure>


        <h4 id="请安装-vagrant-hostmanager-插件"   >
          <a href="#请安装-vagrant-hostmanager-插件" class="heading-link"><i class="fas fa-link"></i></a>请安装 vagrant-hostmanager 插件</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  # https:&#x2F;&#x2F;github.com&#x2F;devopsgroup-io&#x2F;vagrant-hostmanager</span><br><span class="line">  config.hostmanager.enabled &#x3D; true</span><br><span class="line">  config.hostmanager.manage_host &#x3D; true</span><br><span class="line">  config.hostmanager.manage_guest &#x3D; true</span><br><span class="line"></span><br><span class="line">  config.vm.define &quot;test1&quot; do |test1|</span><br><span class="line">    node1.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.11&quot;</span><br><span class="line">    node1.vm.hostname&#x3D;&quot;test1&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  config.vm.define &quot;test2&quot; do |test2|</span><br><span class="line">    node2.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.12&quot;</span><br><span class="line">    node2.vm.hostname&#x3D;&quot;test2&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  config.vm.define &quot;test3&quot; do |test3|</span><br><span class="line">    node3.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.13&quot;</span><br><span class="line">    node3.vm.hostname&#x3D;&quot;test3&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h4 id="启动虚拟机"   >
          <a href="#启动虚拟机" class="heading-link"><i class="fas fa-link"></i></a>启动虚拟机</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></div></figure>


        <h4 id="安装-Docker"   >
          <a href="#安装-Docker" class="heading-link"><i class="fas fa-link"></i></a>安装 Docker</h4>
      <p>虚拟机启动以后，登录到这些虚拟机，然后在上面安装 Docker：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;test.docker.com&#x2F; | sh</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></div></figure>


        <h4 id="创建集群"   >
          <a href="#创建集群" class="heading-link"><i class="fas fa-link"></i></a>创建集群</h4>
      <blockquote>
<p>集群里的服务器有两种身份，一个是 manager （管理员），一种是 worker（工人），在管理员服务器上可以创建服务，扩展服务，更新服务，管理员服务器本身也可以运行服务。先去初始化一个集群服务器，比如我想在 test1 这台服务器上初始化一下，先登录到这台服务器。</p>
</blockquote>

        <h4 id="登录到-test1-服务器"   >
          <a href="#登录到-test1-服务器" class="heading-link"><i class="fas fa-link"></i></a>登录到 test1 服务器</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant ssh test1</span><br></pre></td></tr></table></div></figure>


        <h4 id="初始化-Swarm-集群"   >
          <a href="#初始化-Swarm-集群" class="heading-link"><i class="fas fa-link"></i></a>初始化 Swarm 集群</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --listen-addr test1:2377</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>这样 test1 默认就会是这个集群里的管理员，现在集群里只有一个节点服务器，可以查看一下：<br>docker node ls<br>在初始化集群的时候用了 –listen-addr，指定了一下这个集群管理员的地址还有端口号，默认地址应该是 0.0.0.0 ，这里我用了一个主机名来表示，test1。列出这个选项是让展示一下你可以自由的设置服务器的监听地址与端口号，如果使用主机名，你要保证集群里的其它的服务器可以使用这个主机名访问到这台服务器。<br>加入集群</p>
</blockquote>
<p>有了集群以后，你要让其它的服务器加入进来：</p>

        <h4 id="登录到-test2"   >
          <a href="#登录到-test2" class="heading-link"><i class="fas fa-link"></i></a>登录到 test2</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant ssh test2</span><br></pre></td></tr></table></div></figure>


        <h4 id="让-test2-加入到集群"   >
          <a href="#让-test2-加入到集群" class="heading-link"><i class="fas fa-link"></i></a>让 test2 加入到集群</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --listen-addr node2:2377 test1:2377</span><br></pre></td></tr></table></div></figure>


        <h4 id="登录到-test3"   >
          <a href="#登录到-test3" class="heading-link"><i class="fas fa-link"></i></a>登录到 test3</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant ssh test3</span><br></pre></td></tr></table></div></figure>


        <h4 id="让-test3-加入到集群"   >
          <a href="#让-test3-加入到集群" class="heading-link"><i class="fas fa-link"></i></a>让 test3 加入到集群</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --listen-addr test3:2377 test1:2377</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>现在集群里一共有三台服务器了，在集群的 manager 里面可以查看一下服务器的列表：<br>docker node ls<br>让服务器加入集群的时候，也用到了 –listen-addr 选项，设置了这台服务器监听的地址与端口，其它的服务器会使用这个地址与端口跟它进行交流。后面又指定了让这台服务器加入到的那个集群，也就是通知一下集群里的管理员服务器。<br>创建集群网络</p>
</blockquote>
<blockquote>
<p>集群里的服务器使用一种 overlay 类型的网络，我们可以创建一种这样的网络，然后在集群里运行服务的时候可以指定使用这个网络。在集群的<br>manager 上（test1），执行：</p>
</blockquote>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver overlay skynet</span><br></pre></td></tr></table></div></figure>

<p>这样会创建一个名字是 skynet 的 overlay 类型的网络。<br>创建服务</p>
<blockquote>
<p>在集群的 manger 节点上，可以去创建运行应用的服务，执行一下：</p>
</blockquote>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --name web --network skynet --publish 3000:3000 --replicas 1 devon&#x2F;node</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>上面命令会基于宁皓网的 devon/node 镜像创建一个名字是 web 的服务，使用 skynet 这个名字的网络，发布的端口是 3000 。–replicas 指定了这个服务用一个容器来运行。完成以后，可以打开浏览器，访问一下：</p>
</blockquote>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;test1:3000</span><br><span class="line">http:&#x2F;&#x2F;test2:3000</span><br><span class="line">http:&#x2F;&#x2F;test3:3000</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>虽然 web 这个服务只有一个容器运行，它会在集群里的某台服务器上，很可能是 test1 这个服务器，不管它在哪个服务器上运行，访问集群里的所有的服务器，都可以正常打开服务提供的页面，你应该会在页面上看到一个 hello ，还有运行这个应用的容器的 id 号。<br>扩展服务</p>
</blockquote>
<blockquote>
<p>现在我要用多个容器来运行应用，这些容器会在集群里的不同的服务器上运行。扩展运行服务的容器的数量，在集群的 manager 节点上执行一下：</p>
</blockquote>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service scale web&#x3D;6</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>上面的命令会用 6 个容器同时运行 web 这个服务，这 6 个容器会分布在不同的服务器上，查看运行服务的任务，执行一下：</p>
</blockquote>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service tasks web</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>你会看到在哪些服务器上运行了 web 这个服务。在不同的浏览器上再访问一下应用的页面，你会发现，运行应用的容器的 id 号会有变化，也就是用户对应用的请求会被均衡的分布在不同的服务器上。<br>更新服务</p>
</blockquote>
<blockquote>
<p>服务被创建以后，可以更新它，比如服务的端口号，数据卷，网络，镜像，这些东西都可以更新。我要更新一下 web 服务用的镜像，在集群的 manager 上执行：</p>
</blockquote>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service update web --image devon&#x2F;node:fanxiao2</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>它会让 web 服务基于新的镜像 devon/node:fanxiao2 去创建，更新完成以后，重新打开浏览器，访问一下应用的页面，页面上显示的内容会有变化。<br>如果发现下面的错误：</p>
</blockquote>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --listen-addr test1:2377 了 提示 docker: &#39;swarm&#39; is not a docker command. See &#39;docker --help&#39;.</span><br></pre></td></tr></table></div></figure>
<p>这是版本问题导致的，请把docker 升级到 1.12及以上</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2017/08/10/1490408777.484703/">热更新</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2017-08-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-09-03</span></span></div></header><div class="post-body"><div class="post-excerpt"><blockquote>
<p>首先你应该有一个基于React Native开发的应用，我们把具有package.json的目录叫做你的”应用根目录”。<br>如果你还没有初始化应用，请参阅开始使用React Native。<br>所以我们也假设你已经拥有了开发React Native应用的一切环境，包括Node.js、npm、XCode、Android SDK等等。<br>如果你之前没安装过，你还必须安装Android NDK，并设置环境变量ANDROID_NDK_HOME，指向你的NDK根目录(例如/Users/tdzl2003/Downloads/android-ndk-r10e)。<br>安装</p>
</blockquote>
<p>在你的项目根目录下运行以下命令(不要输入开头的美元符号)：</p>

        <h5 id="RN-0-29及以上"   >
          <a href="#RN-0-29及以上" class="heading-link"><i class="fas fa-link"></i></a>RN 0.29及以上:</h5>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g react-native-update-cli</span><br><span class="line">$ npm install --save react-native-update</span><br><span class="line">$ react-native link react-native-update</span><br><span class="line">npm install -g react-native-update-cli这一句在每一台电脑上仅需运行一次。</span><br></pre></td></tr></table></div></figure>

        <h5 id="RN-0-27-0-28"   >
          <a href="#RN-0-27-0-28" class="heading-link"><i class="fas fa-link"></i></a>RN 0.27-0.28:</h5>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g react-native-update-cli rnpm</span><br><span class="line">$ npm install --save react-native-update@2.x</span><br><span class="line">$ rnpm link react-native-update</span><br><span class="line">npm install -g react-native-update-cli rnpm这一句在每一台电脑上仅需运行一次。</span><br></pre></td></tr></table></div></figure>


        <h5 id="RN-0-26及以下"   >
          <a href="#RN-0-26及以下" class="heading-link"><i class="fas fa-link"></i></a>RN 0.26及以下:</h5>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g react-native-update-cli rnpm</span><br><span class="line">$ npm install --save --save-exact react-native-update@1.0.x</span><br><span class="line">$ rnpm link react-native-update</span><br><span class="line">npm install -g react-native-update-cli rnpm这一句在每一台电脑上仅需运行一次。</span><br></pre></td></tr></table></div></figure>

<p>  ● 注意 *<br>如果访问极慢或者显示网络失败，请使用淘宝镜像： </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org --global</span><br><span class="line">npm config set disturl https:&#x2F;&#x2F;npm.taobao.org&#x2F;dist --global</span><br></pre></td></tr></table></div></figure>

<p>手动安装<br>如果第一步已成功(iOS工程和安卓工程均能看到依赖),可以跳过此步骤</p>

        <h4 id="iOS"   >
          <a href="#iOS" class="heading-link"><i class="fas fa-link"></i></a>iOS</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 在XCode中的Project Navigator里,右键点击Libraries ➜ Add Files to [你的工程名]</span><br><span class="line">2. 进入node_modules ➜ react-native-update ➜ ios 并选中RCTHotUpdate.xcodeproj&#96;</span><br><span class="line">3. 在XCode中的project navigator里,选中你的工程,在 Build Phases ➜ Link Binary With Libraries 中添加 libRCTHotUpdate.a</span><br><span class="line">4. Run your project (Cmd+R)</span><br></pre></td></tr></table></div></figure>


        <h4 id="Android"   >
          <a href="#Android" class="heading-link"><i class="fas fa-link"></i></a>Android</h4>
        <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  1. 在android&#x2F;settings.gradle中添加如下代码:  include &#39;:react-native-update&#39; project(&#39;:react-native-update&#39;).projectDir &#x3D; new File(rootProject.projectDir, &#39;..&#x2F;node_modules&#x2F;react-native-update&#x2F;android&#39;)</span><br><span class="line">  2. 在android&#x2F;app&#x2F;build.gradle的 dependencies 部分增加如下代码:  compile project(&#39;:react-native-update&#39;) </span><br><span class="line">  3. 检查你的RN版本,如果是0.29及以上, 打开android&#x2F;app&#x2F;src&#x2F;main&#x2F;java&#x2F;[...]&#x2F;MainApplication.java,否则打开android&#x2F;app&#x2F;src&#x2F;main&#x2F;java&#x2F;[...]&#x2F;MainActivity.java</span><br><span class="line">      ○ 在文件开头增加 import cn.reactnative.modules.update.UpdatePackage;</span><br><span class="line">      ○ 在getPackages() 方法中增加 new UpdatePackage()(注意上一行可能要增加一个逗号)</span><br><span class="line">配置Bundle URL(iOS)</span><br><span class="line">在工程target的Build Phases-&gt;Link Binary with Libraries中加入libz.tbd、libbz2.1.0.tbd</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>在你的AppDelegate.m文件中增加如下代码：<br>// … 其它代码</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;RCTHotUpdate.h&quot;</span><br><span class="line"></span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">#if DEBUG</span><br><span class="line">  &#x2F;&#x2F; 原来的jsCodeLocation</span><br><span class="line">  jsCodeLocation &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;localhost:8081&#x2F;index.ios.bundle?platform&#x3D;ios&amp;dev&#x3D;true&quot;];</span><br><span class="line">#else</span><br><span class="line">  jsCodeLocation&#x3D;[RCTHotUpdate bundleURL];</span><br><span class="line">#endif</span><br><span class="line">  &#x2F;&#x2F; ... 其它代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="配置Bundle-URL-Android"   >
          <a href="#配置Bundle-URL-Android" class="heading-link"><i class="fas fa-link"></i></a>配置Bundle URL(Android)</h5>
      <p>0.29及以后版本：在你的MainApplication中增加如下代码：<br>// … 其它代码</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import cn.reactnative.modules.update.UpdateContext;</span><br><span class="line">public class MainApplication extends Application implements ReactApplication &#123;</span><br><span class="line"></span><br><span class="line">  private final ReactNativeHost mReactNativeHost &#x3D; new ReactNativeHost(this) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected String getJSBundleFile() &#123;</span><br><span class="line">        return UpdateContext.getBundleUrl(MainApplication.this);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; ... 其它代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">0.28及以前版本：在你的MainActivity中增加如下代码：</span><br><span class="line">&#x2F;&#x2F; ... 其它代码</span><br><span class="line"></span><br><span class="line">import cn.reactnative.modules.update.UpdateContext;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends ReactActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String getJSBundleFile() &#123;</span><br><span class="line">        return UpdateContext.getBundleUrl(this);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; ... 其它代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h5 id="iOS的ATS例外配置"   >
          <a href="#iOS的ATS例外配置" class="heading-link"><i class="fas fa-link"></i></a>iOS的ATS例外配置</h5>
      <p>从iOS9开始，苹果要求以白名单的形式在Info.plist中列出外部的非https接口，以督促开发者部署https协议。在我们的服务部署https协议之前，请在Info.plist中添加如下例外（右键点击Info.plist，选择open as - source code）：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;NSAppTransportSecurity&lt;&#x2F;key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;NSExceptionDomains&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;reactnative.cn&lt;&#x2F;key&gt;</span><br><span class="line">        &lt;dict&gt;</span><br><span class="line">            &lt;key&gt;NSIncludesSubdomains&lt;&#x2F;key&gt;</span><br><span class="line">            &lt;true&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;dict&gt;</span><br><span class="line">   &lt;&#x2F;dict&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>登录与创建应用<br>在你的项目根目录下运行以下命令：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pushy login</span><br><span class="line">email: &lt;输入你的注册邮箱&gt;</span><br><span class="line">password: &lt;输入你的密码&gt;</span><br></pre></td></tr></table></div></figure>

<p>这会在项目文件夹下创建一个.update文件，注意不要把这个文件上传到Git等CVS系统上。你可以在.gitignore末尾增加一行.update来忽略这个文件。<br>登录之后可以创建应用。注意iOS平台和安卓平台需要分别创建：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pushy createApp --platform ios</span><br></pre></td></tr></table></div></figure>
<p>App Name: &lt;输入应用名字&gt;</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pushy createApp --platform android</span><br></pre></td></tr></table></div></figure>
<p>App Name: &lt;输入应用名字&gt;<br>两次输入的名字可以相同，这没有关系。<br>如果你已经在网页端或者其它地方创建过应用，也可以直接选择应用：<br>$ pushy selectApp –platform ios</p>
<ol>
<li>鱼多多(ios)</li>
<li>招财旺(ios)</li>
</ol>
<p>Total 2 ios apps<br>Enter appId: &lt;输入应用前面的编号&gt;<br>选择或者创建过应用后，你将可以在文件夹下看到update.json文件，其内容类似如下形式：<br>{<br>    “ios”: {<br>        “appId”: 1,<br>        “appKey”: “&lt;一串随机字符串&gt;”<br>    },<br>    “android”: {<br>        “appId”: 2,<br>        “appKey”: “&lt;一串随机字符串&gt;”<br>    }<br>}<br>你可以安全的把update.json上传到Git等CVS系统上，与你的团队共享这个文件，它不包含任何敏感信息。当然，他们在使用任何功能之前，都必须首先输入pushy login进行登录。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2017/08/10/1490408789.503871/">Docker常用命令</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2017-08-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-09-03</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h4 id="查看镜像"   >
          <a href="#查看镜像" class="heading-link"><i class="fas fa-link"></i></a>查看镜像</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">包含 仓库名，标签，镜像ID，创建时间以及所占用的空间</span><br></pre></td></tr></table></div></figure>


        <h4 id="此命令回去执行-拉取DockerHub的镜像源"   >
          <a href="#此命令回去执行-拉取DockerHub的镜像源" class="heading-link"><i class="fas fa-link"></i></a>此命令回去执行 拉取DockerHub的镜像源</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull &lt;名称&gt; &lt;版本&gt; （默认会pull最新版本）</span><br></pre></td></tr></table></div></figure>


        <h4 id="运行镜像"   >
          <a href="#运行镜像" class="heading-link"><i class="fas fa-link"></i></a>运行镜像</h4>
      <p>docker run 就是运行容器的命令, -it -i:交互式操作, -t终端 进入bash –rm 是指容器退出后随之将其删除</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm ubuntu:14.04 bash</span><br><span class="line">root@9839c757a804:&#x2F;# cat &#x2F;etc&#x2F;os-release </span><br><span class="line">NAME&#x3D;&quot;Ubuntu&quot;</span><br><span class="line">VERSION&#x3D;&quot;14.04.5 LTS, Trusty Tahr&quot;</span><br><span class="line">ID&#x3D;ubuntu</span><br><span class="line">ID_LIKE&#x3D;debian</span><br><span class="line">PRETTY_NAME&#x3D;&quot;Ubuntu 14.04.5 LTS&quot;</span><br><span class="line">VERSION_ID&#x3D;&quot;14.04&quot;</span><br><span class="line">HOME_URL&#x3D;&quot;http:&#x2F;&#x2F;www.ubuntu.com&#x2F;&quot;</span><br><span class="line">SUPPORT_URL&#x3D;&quot;http:&#x2F;&#x2F;help.ubuntu.com&#x2F;&quot;</span><br><span class="line">BUG_REPORT_URL&#x3D;&quot;http:&#x2F;&#x2F;bugs.launchpad.net&#x2F;ubuntu&#x2F;&quot;</span><br></pre></td></tr></table></div></figure>


        <h4 id="虚悬镜像"   >
          <a href="#虚悬镜像" class="heading-link"><i class="fas fa-link"></i></a>虚悬镜像</h4>
      <p>有有时我们会pull下来类似于这样的镜像</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;none&gt;   &lt;none&gt;   00285df0df87    5day ago  342 MB</span><br></pre></td></tr></table></div></figure>
<p>此镜像其实是有标签存在的，只是随着官网的镜像维护更新后 重新pull时这个镜像被转移到了新的镜像身上，而旧镜像本身的名称被取消，所以显示none 当然  docker build 也会出现同样的现象</p>
<p>此条命令可以显示这类镜像</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -f dangling&#x3D;true</span><br></pre></td></tr></table></div></figure>

<p>我们可以用下面命令删除此类镜像</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q -f dangling&#x3D;true)</span><br></pre></td></tr></table></div></figure>


        <h4 id="中间层镜像"   >
          <a href="#中间层镜像" class="heading-link"><i class="fas fa-link"></i></a>中间层镜像</h4>
      <p>与虚悬镜像不同，她是其它一些镜像的依赖镜像不可删除，删除的话可能导致一些依赖丢失从而出错。相同的层只会存一遍，所以它们的存在对你来说没有什么影响</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -a </span><br></pre></td></tr></table></div></figure>

<p>我现在想查看我在ubuntu:16.04 这个镜像之后pull的镜像</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker images -f since&#x3D;ubuntu:16.04</span><br><span class="line"></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nest_console        latest              04aeff17b50c        3 hours ago         531.4 MB</span><br><span class="line">nest_php            latest              c230b821f887        4 hours ago         504.4 MB</span><br><span class="line">centos              latest              67591570dd29        3 days ago          191.8 MB</span><br></pre></td></tr></table></div></figure>


<p>-f 是–filter的简写。 如果想看到某个位置之前的镜像 可以将since换成 before</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -f before&#x3D;ubuntu:16.04</span><br></pre></td></tr></table></div></figure>

<p>当然也可以通过LABEL来进行过滤</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -f label&#x3D;com.example.version&#x3D;0.1</span><br></pre></td></tr></table></div></figure>

<p>我们先去创建并启动一个容器并监听本地端口8080</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name webnginx -d -p8080:80 nginx</span><br></pre></td></tr></table></div></figure>

<p>通过终端方式进入 webnginx 容器</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it webnginx bash</span><br></pre></td></tr></table></div></figure>

<p>使用命令修改nginx的数据内容：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;&lt;h1&gt;hello fanxiao2&lt;&#x2F;h1&gt;&quot; &gt;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></div></figure>

<p>我们修改了文件，于是乎也动用了容器的存储层，使用命令可以查看具体改动</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker diff webnginx</span><br><span class="line">C &#x2F;root</span><br><span class="line">A &#x2F;root&#x2F;.bash_history</span><br><span class="line">C &#x2F;run</span><br><span class="line">A &#x2F;run&#x2F;nginx.pid</span><br><span class="line">C &#x2F;usr</span><br><span class="line">C &#x2F;usr&#x2F;share</span><br><span class="line">C &#x2F;usr&#x2F;share&#x2F;nginx</span><br><span class="line">C &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line">C &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br><span class="line">C &#x2F;var</span><br><span class="line">C &#x2F;var&#x2F;cache</span><br><span class="line">C &#x2F;var&#x2F;cache&#x2F;nginx</span><br><span class="line">A &#x2F;var&#x2F;cache&#x2F;nginx&#x2F;client_temp</span><br><span class="line">A &#x2F;var&#x2F;cache&#x2F;nginx&#x2F;fastcgi_temp</span><br><span class="line">A &#x2F;var&#x2F;cache&#x2F;nginx&#x2F;proxy_temp</span><br><span class="line">A &#x2F;var&#x2F;cache&#x2F;nginx&#x2F;scgi_temp</span><br><span class="line">A &#x2F;var&#x2F;cache&#x2F;nginx&#x2F;uwsgi_temp</span><br></pre></td></tr></table></div></figure></div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">人生没有如果，命运没有假设；不要尽力而为，而要全力以赴；想要不可替代，就必须与众不同。</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">9</div><div class="sidebar-ov-state-item__name">Archives</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>FanJun</span><span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.1.1"></script><script src="/js/stun-boot.js?v=2.1.1"></script><script src="/js/scroll.js?v=2.1.1"></script><script src="/js/header.js?v=2.1.1"></script><script src="/js/sidebar.js?v=2.1.1"></script></body></html>